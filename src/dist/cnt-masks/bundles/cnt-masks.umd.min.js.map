{"version":3,"sources":["../../../projects/cnt-masks/src/lib/cc/card-expiration.pipe.ts","../../../projects/cnt-masks/src/lib/cc/card-expiration.pipe.mock.ts","../../../node_modules/tslib/tslib.es6.js","../../../projects/cnt-masks/src/lib/cc/payment.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-cvc-format.directive.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-cvc-format.directive.mock.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-expiry-format.directive.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-expiry-format.directive.mock.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-number-format.directive.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-number-format.directive.mock.ts","../../../projects/cnt-masks/src/lib/cc/validators/credit-card.validator.ts","../../../projects/cnt-masks/src/lib/mask/adjust-caret-position.function.ts","../../../projects/cnt-masks/src/lib/mask/conform-to-mask.function.ts","../../../projects/cnt-masks/src/lib/mask/create-text-mask-input-element.function.ts","../../../projects/cnt-masks/src/lib/angular-2-text-mask.module.ts","../../../projects/cnt-masks/src/lib/phone/utils.ts","../../../projects/cnt-masks/src/lib/phone/phone-mask.directive.ts","../../../projects/cnt-masks/src/lib/phone/phone-mask.pipe.ts","../../../projects/cnt-masks/src/lib/cnt-masks.module.ts","../../../projects/cnt-masks/src/lib/phone/phone-mask.directive.mock.ts","../../../projects/cnt-masks/src/lib/phone/phone-mask.pipe.mock.ts"],"names":["CardExpirationPipe","prototype","transform","value","length","substring","Pipe","args","name","CardExpirationPipeMock","Object","create","__values","o","s","Symbol","iterator","m","i","call","next","done","TypeError","cards","defaultFormat","indexOf","item","l","this","cardFromNumber","num","card","len","numString","replace","pattern","test","cardFromType","type","hasTextSelected","target","selectionStart","selectionEnd","error","qjon","element","eventName","callback","_c","Array","from","_d","match","addEventListener","attachEvent","_e","split","_f","trigger","el","data","ev","CustomEvent","detail","e","document","createEvent","initCustomEvent","initEvent","dispatchEvent","format","cvcLength","luhn","Payment","restrictNumeric","formatCardCVC","restrictCVC","formatCardExpiry","month","year","formatCardExpiryMultiple","restrictCombinedExpiry","formatExpiry","formatForwardSlash","formatForwardExpiry","formatBackExpiry","restrictMonthExpiry","formatMonthExpiry","restrictYearExpiry","formatCardNumber","maxLength","digit","String","fromCharCode","which","Math","min","preventDefault","restrictCardNumber","upperLength","upperLengths","j","filter","x","formatBackCardNumber","setCardType","reFormatCardNumber","setTimeout","fns","meta","val","metaKey","input","ctrlKey","restrictExpiry","cardType","classList","contains","add","forEach","remove","cardExpiryVal","ref","Date","getFullYear","toString","slice","validateCardNumber","odd","sum","reverse","digitString","parseInt","luhnCheck","validateCardExpiry","currentTime","expiry","ref1","trim","monthInt","setMonth","getMonth","validateCardCVC","cvc","groups","global","join","exec","shift","n","nativeElement","Directive","selector","ElementRef","CCNumberFormatDirective","renderer","onKeypress","elementValue","removeClass","Renderer2","HostListener","CreditCardValidator","control","cardNumber","controlValue","isValid","cardExpiry","validateCardCvc","cardCvc","defaultArray","emptyString","defaultPlaceholderChar","emptyArray","processCaretTraps","mask","indexOfCaretTrap","indexes","push","splice","maskWithoutCaretTraps","conformToMask","rawValue","config","emptyString$1","isArray","Error","_a","guide","_b","previousConformedValue","placeholderChar","placeholder","JSON","stringify","map","char","RegExp","convertMaskToPlaceholder","currentCaretPosition","keepCharPositions","suppressGuide","undefined","rawValueLength","previousConformedValueLength","placeholderLength","maskLength","editDistance","isAddition","indexOfFirstChange","indexOfLastChange","abs","compensatingPlaceholderChars","rawValueArr","isNew","conformedValue","someCharsRejected","placeholderLoop","charInPlaceholder","rawValueChar","rawValueArrLength","indexOfNextAvailablePlaceholderChar","charData","substr","indexOfLastFilledPlaceholderChar","isAndroid","navigator","userAgent","defer","requestAnimationFrame","isString","emptyArray$1","createTextMaskInputElement","state","previousPlaceholder","update","inputElement","providedMask","pipe","showMask","caretTrapIndexes","safeRawValue","inputValue","isNaN","getSafeRawValue","conformToMaskConfig","piped","pipeResults","assign","rejected","selectionPosition","finalConformedValue","adjustedCaretPosition","indexesOfPipedChars","conformedValueLength","editLength","trackRightCharacter","targetChar","startingSearchIndex","normalizedConformedValue_1","toLowerCase","intersection","previousLeftMaskChars","masklengthChanged","targetIsMaskMovingLeft","countTargetCharInPipedChars","index","countTargetCharInIntersection","requiredNumberOfMatches","numberOfEncounteredMatches","lastPlaceholderChar","adjustCaretPosition","inputElementValue","activeElement","setSelectionRange","MASKEDINPUT_VALUE_ACCESSOR","provide","NG_VALUE_ACCESSOR","useExisting","forwardRef","MaskedInputDirective","multi","_renderer","_elementRef","_compositionMode","textMaskConfig","_composing","onChange","_","onTouched","getDOM","getUserAgent","ngOnChanges","changes","_setupMask","textMaskInputElement","writeValue","normalizedValue","setProperty","registerOnChange","fn","registerOnTouched","setDisabledState","isDisabled","_handleInput","tagName","toUpperCase","getElementsByTagName","_compositionStart","_compositionEnd","host","(input)","(blur)","(compositionstart)","(compositionend)","exportAs","providers","Optional","Inject","COMPOSITION_BUFFER_MODE","Input","NgModule","declarations","exports","PhoneMaskDirective","elementRef","platformId","compositionMode","clean","maxNumberLength","composing","ngOnInit","setupMask","onBlur","handleInput","compositionStart","compositionEnd","isPlatformBrowser","window","PLATFORM_ID","PhoneMaskPipe","imports","TextMaskModule","CCExpiryFormatDirective","CCCvcFormatDirective","PhoneMaskDirectiveMock","PhoneMaskPipeMock"],"mappings":"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","sourcesContent":["import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'cardExpiration',\n})\nexport class CardExpirationPipe implements PipeTransform {\n  transform(value: string): string {\n    if (typeof value !== 'number') {\n      value = value + '';\n    }\n\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    if (value.length === 3) {\n      value = `0${value}`;\n    }\n\n    return `${value.substring(0, 2)}/${value.substring(2)}`;\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'cardExpiration',\n})\nexport class CardExpirationPipeMock implements PipeTransform {\n  transform(value: string): string {\n    return value;\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/**\n * Based on:\n * Copyright (c) 2014 Jesse Pollak\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH TH\n */\ninterface ICardObject {\n  type: string;\n  pattern: RegExp;\n  format: RegExp;\n  length: number[];\n  cvcLength: number[];\n  luhn: boolean;\n}\n\nlet cards: ICardObject[];\nlet defaultFormat;\n\nconst indexOf =\n  [].indexOf ||\n  function (this: any[], item: any): number {\n    for (let i = 0, l = this.length; i < l; i++) {\n      if (i in this && this[i] === item) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\ndefaultFormat = /(\\d{1,4})/g;\n\ncards = [\n  {\n    type: 'amex',\n    pattern: /^3[47]/,\n    format: /(\\d{1,4})(\\d{1,6})?(\\d{1,5})?/,\n    length: [15],\n    cvcLength: [4],\n    luhn: true,\n  },\n  {\n    type: 'dankort',\n    pattern: /^5019/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'hipercard',\n    pattern: /^(384100|384140|384160|606282|637095|637568|60(?!11))/,\n    format: defaultFormat,\n    length: [14, 15, 16, 17, 18, 19],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'dinersclub',\n    pattern: /^(36|38|30[0-5])/,\n    format: /(\\d{1,4})(\\d{1,6})?(\\d{1,4})?/,\n    length: [14],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'discover',\n    pattern: /^(6011|65|64[4-9]|622)/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'jcb',\n    pattern: /^35/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'laser',\n    pattern: /^(6706|6771|6709)/,\n    format: defaultFormat,\n    length: [16, 17, 18, 19],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'maestro',\n    pattern: /^(5018|5020|5038|6304|6703|6708|6759|676[1-3])/,\n    format: defaultFormat,\n    length: [12, 13, 14, 15, 16, 17, 18, 19],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'mastercard',\n    pattern: /^(5[1-5]|677189)|^(222[1-9]|2[3-6]\\d{2}|27[0-1]\\d|2720)/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'unionpay',\n    pattern: /^62/,\n    format: defaultFormat,\n    length: [16, 17, 18, 19],\n    cvcLength: [3],\n    luhn: false,\n  },\n  {\n    type: 'visaelectron',\n    pattern: /^4(026|17500|405|508|844|91[37])/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'elo',\n    // tslint:disable-next-line:max-line-length\n    pattern: /^(4011(78|79)|43(1274|8935)|45(1416|7393|763(1|2))|50(4175|6699|67[0-7][0-9]|9000)|627780|63(6297|6368)|650(03([^4])|04([0-9])|05(0|1)|4(0[5-9]|3[0-9]|8[5-9]|9[0-9])|5([0-2][0-9]|3[0-8])|9([2-6][0-9]|7[0-8])|541|700|720|901)|651652|655000|655021)/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'visa',\n    pattern: /^4/,\n    format: defaultFormat,\n    length: [13, 16, 19],\n    cvcLength: [3],\n    luhn: true,\n  },\n];\n\nfunction cardFromNumber(num: string): any {\n  let card;\n  let i;\n  let len;\n  const numString = (num + '').replace(/\\D/g, '');\n  for (i = 0, len = cards.length; i < len; i++) {\n    card = cards[i];\n    if (card.pattern.test(numString)) {\n      return card;\n    }\n  }\n\n  return;\n}\n\nfunction cardFromType(type: string): any {\n  let card;\n  let i;\n  let len;\n  for (i = 0, len = cards.length; i < len; i++) {\n    card = cards[i];\n    if (card.type === type) {\n      return card;\n    }\n  }\n\n  return;\n}\n\nfunction luhnCheck(num: string): boolean {\n  let digits;\n  let odd = true;\n  let sum = 0;\n\n  digits = (num + '').split('').reverse();\n\n  digits.forEach((digitString) => {\n    let digit = parseInt(digitString, 10);\n    odd = !odd;\n    if (odd) {\n      digit *= 2;\n    }\n    if (digit > 9) {\n      digit -= 9;\n    }\n    return (sum += digit);\n  });\n\n  return sum % 10 === 0;\n}\n\nfunction hasTextSelected(target?: EventTarget): boolean {\n  let e;\n  try {\n    // If some text is selected\n    if (\n      target &&\n      (target as any).selectionStart != null &&\n      (target as any).selectionStart !== (target as any).selectionEnd\n    ) {\n      return true;\n    }\n  } catch (error) {\n    e = error;\n  }\n\n  return false;\n}\n\nfunction qjon(\n  element: Element | any,\n  eventName: string,\n  callback: (e: Event) => void\n): any {\n  if (element.length) {\n    // handle multiple elements\n    for (const el of Array.from(element)) {\n      qjon(el, eventName, callback);\n    }\n    return;\n  }\n\n  if (eventName.match(' ')) {\n    // handle multiple event attachment\n    for (const multiEventName of Array.from(eventName.split(' '))) {\n      qjon(element, multiEventName, callback);\n    }\n    return;\n  }\n\n  if (element.addEventListener) {\n    return element.addEventListener(eventName, callback, false);\n  }\n\n  if (element.attachEvent) {\n    eventName = 'on' + eventName;\n    return element.attachEvent(eventName, callback);\n  }\n\n  element['on' + eventName] = callback;\n}\n\nfunction trigger(el: Element, name: string, data?: any): boolean {\n  let ev;\n\n  try {\n    ev = new CustomEvent(name, { detail: data });\n  } catch (e) {\n    ev = document.createEvent('CustomEvent');\n    // jsdom doesn't have initCustomEvent, so we need this check for\n    // testing\n    if (ev.initCustomEvent) {\n      ev.initCustomEvent(name, true, true, data);\n    } else {\n      (ev as any).initEvent(name, true, true, data);\n    }\n  }\n\n  return el.dispatchEvent(ev);\n}\n\n// Public\n// @dynamic\nexport class Payment {\n  public static fns = {\n    cardExpiryVal: (value: string) => {\n      let month;\n      let prefix;\n      let year;\n      let ref;\n\n      value = value.replace(/\\s/g, '');\n      (ref = value.split('/', 2)), (month = ref[0]), (year = ref[1]);\n\n      // Allow for year shortcut\n      if ((year != null ? year.length : void 0) === 2 && /^\\d+$/.test(year)) {\n        prefix = new Date().getFullYear();\n        prefix = prefix.toString().slice(0, 2);\n        year = prefix + year;\n      }\n\n      return {\n        month,\n        year,\n      };\n    },\n    validateCardNumber: (num: string) => {\n      let card;\n      let ref;\n\n      num = (num + '').replace(/\\s+|-/g, '');\n      if (!/^\\d+$/.test(num)) {\n        return false;\n      }\n\n      card = cardFromNumber(num);\n      if (!card) {\n        return false;\n      }\n\n      return (\n        ((ref = num.length), indexOf.call(card.length, ref) >= 0) &&\n        (card.luhn === false || luhnCheck(num))\n      );\n    },\n    validateCardExpiry: (month: string, year: string) => {\n      // Allow passing an object\n      let currentTime;\n      let expiry;\n      let prefix;\n      let ref1;\n\n      if (typeof month === 'string' && indexOf.call(month, '/') >= 0) {\n        (ref1 = Payment.fns.cardExpiryVal(month)),\n          (month = ref1.month),\n          (year = ref1.year);\n      }\n\n      if (!(month && year)) {\n        return false;\n      }\n\n      month = month.trim();\n      year = year.trim();\n\n      if (!/^\\d+$/.test(month)) {\n        return false;\n      }\n      if (!/^\\d+$/.test(year)) {\n        return false;\n      }\n\n      const monthInt = parseInt(month, 10);\n\n      if (!(monthInt && monthInt <= 12)) {\n        return false;\n      }\n\n      if (year.length === 2) {\n        prefix = new Date().getFullYear();\n        prefix = prefix.toString().slice(0, 2);\n        year = prefix + year;\n      }\n\n      expiry = new Date(parseInt(year, 10), monthInt);\n      currentTime = new Date();\n\n      // Months start from 0 in JavaScript\n      expiry.setMonth(expiry.getMonth() - 1);\n\n      // The cc expires at the end of the month,\n      // so we need to make the expiry the first day\n      // of the month after\n      expiry.setMonth(expiry.getMonth() + 1, 1);\n\n      return expiry > currentTime;\n    },\n    validateCardCVC: (cvc: string, type?: string) => {\n      let ref;\n      let ref1;\n\n      cvc = cvc.trim();\n      if (!/^\\d+$/.test(cvc)) {\n        return false;\n      }\n\n      if (type && cardFromType(type)) {\n        // Check against a explicit card type\n        ref1 = cardFromType(type);\n        return (\n          (ref = cvc.length),\n          indexOf.call(ref1 != null ? ref1.cvcLength : void 0, ref) >= 0\n        );\n      } else {\n        // Check against all types\n        return cvc.length >= 3 && cvc.length <= 4;\n      }\n    },\n    cardType: (num: string) => {\n      if (!num) {\n        return null;\n      }\n      const ref = cardFromNumber(num);\n      return (ref != null ? ref.type : void 0) || null;\n    },\n    formatCardNumber: (num: string) => {\n      let card;\n      let groups;\n      let upperLength;\n\n      card = cardFromNumber(num);\n      if (!card) {\n        return num;\n      }\n\n      upperLength = card.length[card.length.length - 1];\n\n      num = num.replace(/\\D/g, '');\n      num = num.slice(0, upperLength);\n\n      if (card.format.global) {\n        const ref = num.match(card.format);\n        return ref != null ? ref.join(' ') : void 0;\n      } else {\n        groups = card.format.exec(num);\n        if (groups == null) {\n          return;\n        }\n        groups.shift();\n        groups = groups.filter((n) => n); // Filter empty groups\n        return groups.join(' ');\n      }\n    },\n  };\n\n  public static restrictNumeric(el: Element): any {\n    return qjon(el, 'keypress', restrictNumeric);\n  }\n\n  public static formatCardCVC(el: Element): Element {\n    Payment.restrictNumeric(el);\n    qjon(el, 'keypress', restrictCVC);\n    return el;\n  }\n\n  public static formatCardExpiry(el: Element): Element {\n    let month;\n    let year;\n\n    Payment.restrictNumeric(el);\n    if ((el as any).length && (el as any).length === 2) {\n      (month = (el as any)[0]), (year = (el as any)[1]);\n      this.formatCardExpiryMultiple(month, year);\n    } else {\n      qjon(el, 'keypress', restrictCombinedExpiry);\n      qjon(el, 'keypress', formatExpiry);\n      qjon(el, 'keypress', formatForwardSlash);\n      qjon(el, 'keypress', formatForwardExpiry);\n      qjon(el, 'keydown', formatBackExpiry);\n    }\n    return el;\n  }\n\n  public static formatCardExpiryMultiple(month: string, year: string): any {\n    qjon(month, 'keypress', restrictMonthExpiry);\n    qjon(month, 'keypress', formatMonthExpiry);\n    return qjon(year, 'keypress', restrictYearExpiry);\n  }\n\n  public static formatCardNumber(el: Element, maxLength?: number): Element {\n    Payment.restrictNumeric(el);\n    qjon(el, 'keypress', restrictCardNumber(maxLength));\n    qjon(el, 'keypress', formatCardNumber(maxLength));\n    qjon(el, 'keydown', formatBackCardNumber);\n    qjon(el, 'keyup blur', setCardType);\n    qjon(el, 'paste', reFormatCardNumber);\n    qjon(el, 'input', reFormatCardNumber);\n    return el;\n  }\n}\n// Private\n\n// Format Card Number\n\nfunction reFormatCardNumber(e: Event): number {\n  return setTimeout(() => {\n    let value;\n    const target = e.target as HTMLDataElement;\n\n    if (!target) {\n      return;\n    }\n\n    value = target.value;\n    value = Payment.fns.formatCardNumber(value);\n    if (value) {\n      target.value = value;\n    }\n    return trigger(target, 'change');\n  });\n}\n\nfunction formatCardNumber(maxLength?: number): (event) => boolean {\n  return (e: Event) => {\n    // Only format if input is a number\n    let card;\n    let digit;\n    let i;\n    let length;\n    let re;\n    let target;\n    let upperLength;\n    let upperLengths;\n    let value;\n    let j;\n    let len;\n    digit = String.fromCharCode((e as any).which);\n    if (!/^\\d+$/.test(digit)) {\n      return;\n    }\n\n    target = e.target as HTMLDataElement;\n    value = target.value;\n    card = cardFromNumber(value + digit);\n    length = (value.replace(/\\D/g, '') + digit).length;\n\n    upperLengths = [16];\n    if (card) {\n      upperLengths = card.length;\n    }\n    if (maxLength) {\n      upperLengths = upperLengths.filter((x) => x <= maxLength);\n    }\n\n    // Return if an upper length has been reached\n    for (i = j = 0, len = upperLengths.length; j < len; i = ++j) {\n      upperLength = upperLengths[i];\n      if (length >= upperLength && upperLengths[i + 1]) {\n        continue;\n      }\n      if (length >= upperLength) {\n        return;\n      }\n    }\n\n    // Return if focus isn't at the end of the text\n    if (hasTextSelected(target)) {\n      return;\n    }\n\n    if (card && card.type === 'amex') {\n      // Amex cards are formatted differently\n      re = /^(\\d{4}|\\d{4}\\s\\d{6})$/;\n    } else {\n      re = /(?:^|\\s)(\\d{4})$/;\n    }\n\n    // If '4242' + 4\n    if (re.test(value)) {\n      e.preventDefault();\n      target.value = value + ' ' + digit;\n      return trigger(target, 'change');\n    }\n\n    return;\n  };\n}\n\nfunction formatBackCardNumber(e: Event): boolean {\n  const target = e.target as HTMLDataElement;\n  const value = target.value;\n\n  if ((e as any).meta) {\n    return;\n  }\n\n  // Return unless backspacing\n  if ((e as any).which !== 8) {\n    return;\n  }\n\n  // Return if focus isn't at the end of the text\n  if (hasTextSelected(target)) {\n    return;\n  }\n\n  // Remove the trailing space\n  if (/\\d\\s$/.test(value)) {\n    e.preventDefault();\n    target.value = value.replace(/\\d\\s$/, '');\n    return trigger(target, 'change');\n  } else if (/\\s\\d?$/.test(value)) {\n    e.preventDefault();\n    target.value = value.replace(/\\s\\d?$/, '');\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\n// Format Expiry\n\nfunction formatExpiry(e: Event): boolean {\n  // Only format if input is a number\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const val = target.value + digit;\n\n  if (/^\\d$/.test(val) && val !== '0' && val !== '1') {\n    e.preventDefault();\n    target.value = '0' + val + ' / ';\n    return trigger(target, 'change');\n  } else if (/^\\d\\d$/.test(val)) {\n    e.preventDefault();\n    target.value = val + ' / ';\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\nfunction formatMonthExpiry(e: Event): boolean {\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const val = target.value + digit;\n\n  if (/^\\d$/.test(val) && val !== '0' && val !== '1') {\n    e.preventDefault();\n    target.value = '0' + val;\n    return trigger(target, 'change');\n  } else if (/^\\d\\d$/.test(val)) {\n    e.preventDefault();\n    target.value = val;\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\nfunction formatForwardExpiry(e: Event): boolean {\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const val = target.value;\n\n  if (/^\\d\\d$/.test(val)) {\n    target.value = val + ' / ';\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\nfunction formatForwardSlash(e: Event): boolean {\n  const slash = String.fromCharCode((e as any).which);\n  if (slash !== '/') {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const val = target.value;\n\n  if (/^\\d$/.test(val) && val !== '0') {\n    target.value = '0' + val + ' / ';\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\nfunction formatBackExpiry(e: Event): boolean {\n  // If shift+backspace is pressed\n  if ((e as any).metaKey) {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const value = target.value;\n\n  // Return unless backspacing\n  if ((e as any).which !== 8) {\n    return;\n  }\n\n  // Return if focus isn't at the end of the text\n  if (hasTextSelected(target)) {\n    return;\n  }\n\n  // Remove the trailing space\n  if (/\\d(\\s|\\/)+$/.test(value)) {\n    e.preventDefault();\n    target.value = value.replace(/\\d(\\s|\\/)*$/, '');\n    return trigger(target, 'change');\n  } else if (/\\s\\/\\s?\\d?$/.test(value)) {\n    e.preventDefault();\n    target.value = value.replace(/\\s\\/\\s?\\d?$/, '');\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\n//  Restrictions\n\nfunction restrictNumeric(e: Event): boolean {\n  // Key event is for a browser shortcut\n  let input;\n  if ((e as any).metaKey || (e as any).ctrlKey) {\n    return true;\n  }\n\n  // If keycode is a space\n  if ((e as any).which === 32) {\n    e.preventDefault();\n    return false;\n  }\n\n  // If keycode is a special char (WebKit)\n  if ((e as any).which === 0) {\n    return true;\n  }\n\n  // If char is a special char (Firefox)\n  if ((e as any).which < 33) {\n    return true;\n  }\n\n  input = String.fromCharCode((e as any).which);\n\n  // Char is a number or a space\n  if (!/[\\d\\s]/.test(input)) {\n    e.preventDefault();\n    return false;\n  }\n}\n\nfunction restrictCardNumber(maxLength?: number): (Event) => void {\n  return (e: Event) => {\n    let length;\n\n    const target = e.target as HTMLDataElement;\n    const digit = String.fromCharCode((e as any).which);\n    if (!/^\\d+$/.test(digit)) {\n      return;\n    }\n\n    if (hasTextSelected(target)) {\n      return;\n    }\n\n    // Restrict number of digits\n    const value = (target.value + digit).replace(/\\D/g, '');\n    const card = cardFromNumber(value);\n\n    length = 16;\n    if (card) {\n      length = card.length[card.length.length - 1];\n    }\n    if (maxLength) {\n      length = Math.min(length, maxLength);\n    }\n\n    if (!(value.length <= length)) {\n      return e.preventDefault();\n    }\n  };\n}\n\nfunction restrictExpiry(e: Event, length: number): void {\n  let value;\n  const target = e.target as HTMLDataElement;\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  if (hasTextSelected(target)) {\n    return;\n  }\n\n  value = target.value + digit;\n  value = value.replace(/\\D/g, '');\n\n  if (value.length > length) {\n    return e.preventDefault();\n  }\n}\n\nfunction restrictCombinedExpiry(e: Event): void {\n  return restrictExpiry(e, 6);\n}\n\nfunction restrictMonthExpiry(e: Event): void {\n  return restrictExpiry(e, 2);\n}\n\nfunction restrictYearExpiry(e: Event): void {\n  return restrictExpiry(e, 4);\n}\n\nfunction restrictCVC(e: Event): void {\n  const target = e.target as HTMLDataElement;\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  if (hasTextSelected(target)) {\n    return;\n  }\n\n  const val = target.value + digit;\n  if (!(val.length <= 4)) {\n    return e.preventDefault();\n  }\n}\n\nfunction setCardType(e: Event): boolean {\n  const target = e.target as HTMLDataElement;\n  const val = target.value;\n  const cardType = Payment.fns.cardType(val) || 'unknown';\n\n  if (target && target.classList && !target.classList.contains(cardType)) {\n    target.classList.add('unknown');\n    cards.forEach((card) => target.classList.remove(card.type));\n\n    target.classList.add(cardType);\n\n    if (cardType !== 'unknown') {\n      if (target.classList.contains('identified')) {\n        target.classList.add('identified');\n      }\n    } else {\n      target.classList.remove('identified');\n    }\n    return trigger(target, 'payment.cardType', cardType);\n  }\n\n  return;\n}\n","import { Directive, ElementRef } from '@angular/core';\n\nimport { Payment } from '../payment';\n\n@Directive({\n  selector: '[cntMaskCCCvc]',\n})\nexport class CCCvcFormatDirective {\n  constructor(private el: ElementRef) {\n    const element = this.el.nativeElement;\n\n    // call lib functions\n    Payment.formatCardCVC(element);\n    Payment.restrictNumeric(element);\n  }\n}\n","import { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[cntMaskCCCvc]',\n})\nexport class CCCvcFormatDirectiveMock {}\n","import { Directive, ElementRef } from '@angular/core';\n\nimport { Payment } from '../payment';\n\n@Directive({\n  selector: '[cntMaskCCExp]',\n})\nexport class CCExpiryFormatDirective {\n  constructor(private el: ElementRef) {\n    const element = this.el.nativeElement;\n\n    // call lib functions\n    Payment.formatCardExpiry(element);\n    Payment.restrictNumeric(element);\n  }\n}\n","import { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[cntMaskCCExp]',\n})\nexport class CCExpiryFormatDirectiveMock {}\n","import { Directive, ElementRef, HostListener, Renderer2 } from '@angular/core';\nimport { Payment } from '../payment';\n\n@Directive({\n  selector: '[cntMaskCCNum]',\n})\nexport class CCNumberFormatDirective {\n  cardType: string | null;\n\n  constructor(private renderer: Renderer2, private el: ElementRef) {\n    const element = this.el.nativeElement;\n    this.cardType = '';\n\n    // call lib functions\n    Payment.formatCardNumber(element);\n    Payment.restrictNumeric(element);\n  }\n\n  @HostListener('keypress', ['$event'])\n  onKeypress(e: Event): void {\n    const element = this.el.nativeElement;\n    const elementValue = element.value;\n\n    this.cardType = Payment.fns.cardType(elementValue);\n\n    if (this.cardType && this.cardType !== '') {\n      this.renderer.removeClass(element, this.cardType);\n    } else {\n      this.cardType = '';\n    }\n  }\n}\n","import { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[cntMaskCCNum]',\n})\nexport class CCNumberFormatDirectiveMock {}\n","import { FormControl, ValidationErrors } from '@angular/forms';\nimport { Payment } from '../payment';\n\nexport class CreditCardValidator {\n  /**\n   * Validates a cc number\n   */\n  static validateCardNumber(control: FormControl): ValidationErrors {\n    if (control) {\n      const isValid = Payment.fns.validateCardNumber(control.value);\n\n      if (!isValid) {\n        return {\n          cardNumber: true,\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validates the expiry date.\n   * Breaks exp by \"/\" string and assumes that first array entry is month and second year\n   * Also removes any spaces\n   */\n  static validateCardExpiry(control: FormControl): ValidationErrors {\n    if (control) {\n      const controlValue = control.value.split('/');\n      let isValid = false;\n\n      if (controlValue.length > 1) {\n        const month = controlValue[0].replace(/^\\s+|\\s+$/g, '');\n        const year = controlValue[1].replace(/^\\s+|\\s+$/g, '');\n\n        isValid = Payment.fns.validateCardExpiry(month, year);\n      }\n\n      if (!isValid) {\n        return {\n          cardExpiry: true,\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validates cards CVC\n   * Also removes any spaces\n   */\n  static validateCardCvc(control: FormControl): ValidationErrors {\n    if (control) {\n      const isValid = Payment.fns.validateCardCVC(control.value);\n\n      if (!isValid) {\n        return {\n          cardCvc: true,\n        };\n      }\n    }\n\n    return null;\n  }\n}\n","const defaultArray = [];\nconst emptyString = '';\n\nexport function adjustCaretPosition({\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = defaultArray,\n  caretTrapIndexes = defaultArray,\n}: any): number {\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  }\n\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const conformedValueLength = conformedValue.length;\n\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength;\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0;\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0;\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit =\n    editLength > 1 && !isAddition && !isFirstRawValue;\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar =\n    isAddition &&\n    (previousConformedValue === conformedValue ||\n      conformedValue === placeholder);\n\n  let startingSearchIndex = 0;\n  let trackRightCharacter;\n  let targetChar;\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase();\n    const normalizedRawValue = rawValue.toLowerCase();\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue\n      .substr(0, currentCaretPosition)\n      .split(emptyString);\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter(\n      (char) => normalizedConformedValue.indexOf(char) !== -1,\n    );\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1];\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter((char) => char !== placeholderChar).length;\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter((char) => char !== placeholderChar).length;\n\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft =\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      previousPlaceholder[intersection.length - 1] !== placeholderChar &&\n      previousPlaceholder[intersection.length - 1] !==\n        placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] ===\n        placeholder[intersection.length - 2];\n\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (masklengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    }\n\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map(\n      (index) => normalizedConformedValue[index],\n    );\n\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter(\n      (char) => char === targetChar,\n    ).length;\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter(\n      (char) => char === targetChar,\n    ).length;\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .substr(0, placeholder.indexOf(placeholderChar))\n      .split(emptyString)\n      .filter(\n        (char, index) =>\n          // Check if `char` is the same as our `targetChar`, so we account for it\n          char === targetChar &&\n          // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n          // index because if they are equal, that means we are already counting those characters in\n          // `countTargetCharInIntersection`\n          rawValue[index] !== char,\n      ).length;\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches =\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      countTargetCharInPipedChars +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0);\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0;\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i];\n\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  }\n\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex;\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i;\n      }\n\n      if (\n        // If we're adding, we can position the caret at the next placeholder character.\n        placeholder[i] === placeholderChar ||\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n        // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n        i === placeholderLength\n      ) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n\n        if (\n          // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n          // to the right of the caret\n          conformedValue[i] === targetChar ||\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n\n        if (\n          // If we're deleting, we can position the caret right before the placeholder character\n          placeholder[i - 1] === placeholderChar ||\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i;\n        }\n      }\n    }\n  }\n}\n","export const defaultPlaceholderChar = '_';\n\nconst emptyArray = [];\nconst emptyString = '';\n\nfunction convertMaskToPlaceholder(\n  mask: any[] = emptyArray,\n  placeholderChar: string = defaultPlaceholderChar,\n): string {\n  if (!Array.isArray(mask)) {\n    throw new Error(\n      'Text-mask:convertMaskToPlaceholder; The mask property must be an array.',\n    );\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n        'that is not present in your mask as your placeholder character.\\n\\n' +\n        `The placeholder character that was received is: ${JSON.stringify(\n          placeholderChar,\n        )}\\n\\n` +\n        `The mask that was received is: ${JSON.stringify(mask)}`,\n    );\n  }\n\n  return mask\n    .map((char) => {\n      return char instanceof RegExp ? placeholderChar : char;\n    })\n    .join('');\n}\n\nconst strCaretTrap = '[]';\nexport function processCaretTraps(\n  mask: any[],\n): { maskWithoutCaretTraps: any; indexes: any[] } {\n  const indexes = [];\n\n  let indexOfCaretTrap;\n  while (\n    // tslint:disable-next-line: no-conditional-assignment\n    ((indexOfCaretTrap = mask.indexOf(strCaretTrap)), indexOfCaretTrap !== -1)\n  ) {\n    // eslint-disable-line\n    indexes.push(indexOfCaretTrap);\n\n    mask.splice(indexOfCaretTrap, 1);\n  }\n\n  return { maskWithoutCaretTraps: mask, indexes };\n}\n\nexport function conformToMask(\n  rawValue: string = emptyString,\n  mask: any[] | any = emptyArray,\n  config: any = {},\n): { conformedValue: string; meta: { someCharsRejected: boolean } } {\n  if (!Array.isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config);\n\n      // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error(\n        'Text-mask:conformToMask; The mask property must be an array.',\n      );\n    }\n  }\n\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = emptyString,\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions,\n  } = config;\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined;\n\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const maskLength = mask.length;\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength;\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange =\n    currentCaretPosition + (isAddition ? -editDistance : 0);\n\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = emptyString;\n\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    }\n\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue =\n      rawValue.slice(0, indexOfFirstChange) +\n      compensatingPlaceholderChars +\n      rawValue.slice(indexOfFirstChange, rawValueLength);\n  }\n\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n    char,\n    isNew: i >= indexOfFirstChange && i < indexOfLastChange,\n  }));\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const { char } = rawValueArr[i];\n\n    if (char !== placeholderChar) {\n      const shouldOffset =\n        i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1);\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString;\n  let someCharsRejected = false;\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i];\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const { char: rawValueChar, isNew } = rawValueArr.shift();\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar;\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop;\n\n            // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (\n              keepCharPositions !== true ||\n              isNew === false ||\n              previousConformedValue === emptyString ||\n              guide === false ||\n              !isAddition\n            ) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length;\n              let indexOfNextAvailablePlaceholderChar = null;\n\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let j = 0; j < rawValueArrLength; j++) {\n                const charData = rawValueArr[j];\n\n                if (\n                  charData.char !== placeholderChar &&\n                  charData.isNew === false\n                ) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = j;\n                  break;\n                }\n              }\n\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n\n                // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                i--;\n              }\n            }\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength);\n      }\n\n      // And we break\n      break;\n\n      // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null;\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(\n        0,\n        indexOfLastFilledPlaceholderChar + 1,\n      );\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString;\n    }\n  }\n\n  return { conformedValue, meta: { someCharsRejected } };\n}\n","import { adjustCaretPosition } from './adjust-caret-position.function';\nimport {\n  conformToMask,\n  defaultPlaceholderChar,\n  processCaretTraps,\n} from './conform-to-mask.function';\n\nconst emptyArray = [];\nconst emptyString = '';\n\nconst isAndroid =\n  typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nconst defer: any =\n  typeof requestAnimationFrame !== 'undefined'\n    ? requestAnimationFrame\n    : setTimeout;\n\nfunction isString(value: any): boolean {\n  return typeof value === 'string' || value instanceof String;\n}\n\nfunction isNumber(value: any): boolean {\n  return (\n    typeof value === 'number' &&\n    (value as any).length === undefined &&\n    !isNaN(value)\n  );\n}\n\nexport function convertMaskToPlaceholder(\n  mask: any = emptyArray,\n  placeholderChar: string = defaultPlaceholderChar,\n): any {\n  if (!Array.isArray(mask)) {\n    throw new Error(\n      'Text-mask:convertMaskToPlaceholder; The mask property must be an array.',\n    );\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n        'that is not present in your mask as your placeholder character.\\n\\n' +\n        `The placeholder character that was received is: ${JSON.stringify(\n          placeholderChar,\n        )}\\n\\n` +\n        `The mask that was received is: ${JSON.stringify(mask)}`,\n    );\n  }\n\n  return mask\n    .map((char) => {\n      return char instanceof RegExp ? placeholderChar : char;\n    })\n    .join('');\n}\n\nexport function createTextMaskInputElement(\n  config: any,\n): { state: any; update: any } {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  const state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined,\n  };\n\n  return {\n    state,\n\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update(\n      rawValue: any,\n      {\n        inputElement,\n        mask: providedMask,\n        guide,\n        pipe,\n        placeholderChar = defaultPlaceholderChar,\n        keepCharPositions = false,\n        showMask = false,\n      }: any = config,\n    ): void {\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      }\n\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === state.previousConformedValue) {\n        return;\n      }\n\n      // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we de-structure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n      if (\n        typeof providedMask === 'object' &&\n        providedMask.pipe !== undefined &&\n        providedMask.mask !== undefined\n      ) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      }\n\n      // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n      let placeholder;\n\n      // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n      let mask;\n\n      // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      }\n\n      // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n      if (providedMask === false) {\n        return;\n      }\n\n      // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n      const safeRawValue = getSafeRawValue(rawValue);\n\n      // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n      const { selectionEnd: currentCaretPosition } = inputElement;\n\n      // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n      const { previousConformedValue, previousPlaceholder } = state;\n\n      let caretTrapIndexes;\n\n      // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition,\n          previousConformedValue,\n          placeholderChar,\n        });\n\n        // disable masking if `mask` is `false`\n        if (mask === false) {\n          return;\n        }\n\n        // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n        const { maskWithoutCaretTraps, indexes } = processCaretTraps(mask);\n\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n        // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      }\n\n      // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n      const conformToMaskConfig = {\n        previousConformedValue,\n        guide,\n        placeholderChar,\n        pipe,\n        placeholder,\n        currentCaretPosition,\n        keepCharPositions,\n      };\n\n      // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n      const { conformedValue } = conformToMask(\n        safeRawValue,\n        mask,\n        conformToMaskConfig,\n      );\n\n      // The following few lines are to support the `pipe` feature.\n      const piped = typeof pipe === 'function';\n\n      let pipeResults = {};\n\n      // If `pipe` is a function, we call it.\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, {\n          rawValue: safeRawValue,\n          ...conformToMaskConfig,\n        });\n\n        // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = { value: previousConformedValue, rejected: true };\n        } else if (isString(pipeResults)) {\n          pipeResults = { value: pipeResults };\n        }\n      }\n\n      // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n      const finalConformedValue = piped\n        ? (pipeResults as any).value\n        : conformedValue;\n\n      // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n      const adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue,\n        previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition,\n        placeholderChar,\n        indexesOfPipedChars: (pipeResults as any).indexesOfPipedChars,\n        caretTrapIndexes,\n      });\n\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      const inputValueShouldBeEmpty =\n        finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      const emptyValue = showMask ? placeholder : emptyString;\n      const inputElementValue = inputValueShouldBeEmpty\n        ? emptyValue\n        : finalConformedValue;\n\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n      state.previousPlaceholder = placeholder;\n\n      // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n\n      inputElement.value = inputElementValue; // set the input value\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    },\n  };\n}\n\nfunction safeSetSelection(element: any, selectionPosition: any): any {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(\n        () =>\n          element.setSelectionRange(\n            selectionPosition,\n            selectionPosition,\n            'none',\n          ),\n        0,\n      );\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue: any): any {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\n      \"The 'value' provided to Text Mask needs to be a string or a number. The value \" +\n        `received was:\\n\\n ${JSON.stringify(inputValue)}`,\n    );\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  forwardRef,\n  Inject,\n  Input,\n  NgModule,\n  OnChanges,\n  Optional,\n  Provider,\n  Renderer2,\n  SimpleChanges,\n} from '@angular/core';\nimport {\n  COMPOSITION_BUFFER_MODE,\n  ControlValueAccessor,\n  NG_VALUE_ACCESSOR,\n} from '@angular/forms';\nimport { getDOM as getDOM } from '@angular/platform-browser';\nimport { createTextMaskInputElement } from './mask/create-text-mask-input-element.function';\n\nexport class TextMaskConfig {\n  mask:\n    | Array<string | RegExp>\n    | ((raw: string) => Array<string | RegExp>)\n    | false;\n  guide?: boolean;\n  placeholderChar?: string;\n  pipe?: (\n    conformedValue: string,\n    config: TextMaskConfig,\n  ) => false | string | object;\n  keepCharPositions?: boolean;\n  showMask?: boolean;\n}\n\nexport const MASKEDINPUT_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MaskedInputDirective),\n  multi: true,\n};\n\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\nfunction _isAndroid(): boolean {\n  const userAgent = getDOM() ? getDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\n\n@Directive({\n  host: {\n    '(input)': '_handleInput($event.target.value)',\n    '(blur)': 'onTouched()',\n    '(compositionstart)': '_compositionStart()',\n    '(compositionend)': '_compositionEnd($event.target.value)',\n  },\n  selector: '[textMask]',\n  exportAs: 'textMask',\n  providers: [MASKEDINPUT_VALUE_ACCESSOR],\n})\nexport class MaskedInputDirective implements ControlValueAccessor, OnChanges {\n  @Input('textMask') textMaskConfig: TextMaskConfig = {\n    mask: [],\n    guide: true,\n    placeholderChar: '_',\n    pipe: undefined,\n    keepCharPositions: false,\n  };\n\n  private textMaskInputElement: any;\n  private inputElement: HTMLInputElement;\n\n  /** Whether the user is creating a composition string (IME events). */\n  private _composing: boolean = false;\n\n  constructor(\n    private _renderer: Renderer2,\n    private _elementRef: ElementRef,\n    @Optional()\n    @Inject(COMPOSITION_BUFFER_MODE)\n    private _compositionMode: boolean,\n  ) {\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n\n  onChange = (_: any) => {\n    // noop\n  };\n  onTouched = () => {\n    // noop\n  };\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this._setupMask(true);\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  }\n\n  writeValue(value: any): void {\n    this._setupMask();\n\n    // set the initial value for cases where the mask is disabled\n    const normalizedValue = value == null ? '' : value;\n    this._renderer.setProperty(this.inputElement, 'value', normalizedValue);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value);\n    }\n  }\n\n  registerOnChange(fn: (_: any) => void): void {\n    this.onChange = fn;\n  }\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(\n      this._elementRef.nativeElement,\n      'disabled',\n      isDisabled,\n    );\n  }\n\n  _handleInput(value: any): void {\n    if (!this._compositionMode || (this._compositionMode && !this._composing)) {\n      this._setupMask();\n\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value);\n\n        // get the updated value\n        value = this.inputElement.value;\n        this.onChange(value);\n      }\n    }\n  }\n\n  _setupMask(create: boolean = false): void {\n    if (!this.inputElement) {\n      if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this._elementRef.nativeElement;\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this._elementRef.nativeElement.getElementsByTagName(\n          'INPUT',\n        )[0];\n      }\n    }\n\n    if (this.inputElement && create) {\n      this.textMaskInputElement = createTextMaskInputElement(\n        Object.assign({ inputElement: this.inputElement }, this.textMaskConfig),\n      );\n    }\n  }\n\n  _compositionStart(): void {\n    this._composing = true;\n  }\n\n  _compositionEnd(value: any): void {\n    this._composing = false;\n    if (this._compositionMode) {\n      this._handleInput(value);\n    }\n  }\n}\n\n@NgModule({\n  declarations: [MaskedInputDirective],\n  exports: [MaskedInputDirective],\n})\nexport class TextMaskModule {}\n","export const clean = (number: string) => {\n  return number.toString().replace(/[^\\d\\^\\+]/gm, '');\n};\n\nexport const mask = (maxLength: number = 13) => (rawValue: string) => {\n  // if (clean(rawValue).length <= 12 || maxLength === 12) {\n  // \treturn ['+', /[1-9]/, ' ', '(', /[1-9]/, /\\d/, /\\d/, ')', ' ', /\\d/, /\\d/, /\\d/, '-', /\\d/, /\\d/, '-', /\\d/, /\\d/];\n  // }\n\n  return [\n    '(',\n    /[1-9]/,\n    /\\d/,\n    /\\d/,\n    ')',\n    ' ',\n    /\\d/,\n    /\\d/,\n    /\\d/,\n    '-',\n    /\\d/,\n    /\\d/,\n    /\\d/,\n    /\\d/,\n  ];\n};\n","import { isPlatformBrowser } from '@angular/common';\nimport {\n  Directive,\n  ElementRef,\n  forwardRef,\n  HostListener,\n  Inject,\n  Input,\n  OnChanges,\n  OnInit,\n  Optional,\n  PLATFORM_ID,\n  Renderer2,\n  SimpleChanges,\n} from '@angular/core';\nimport {\n  COMPOSITION_BUFFER_MODE,\n  ControlValueAccessor,\n  NG_VALUE_ACCESSOR,\n} from '@angular/forms';\nimport { createTextMaskInputElement } from '../mask/create-text-mask-input-element.function';\nimport { clean, mask } from './utils';\n\nexport class TextMaskConfig {\n  public mask:\n    | Array<string | RegExp>\n    | ((raw: string) => Array<string | RegExp>)\n    | false;\n  public guide?: boolean;\n  public placeholderChar?: string;\n  public pipe?: (\n    conformedValue: string,\n    config: TextMaskConfig,\n  ) => false | string | object;\n  public keepCharPositions?: boolean;\n  public showMask?: boolean;\n}\n\n// @dynamic\n@Directive({\n  exportAs: 'cntMaskPhone',\n  providers: [\n    {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => PhoneMaskDirective),\n    },\n  ],\n  selector: '[cntMaskPhone]',\n})\nexport class PhoneMaskDirective\n  implements ControlValueAccessor, OnChanges, OnInit {\n  @Input() public clean: boolean = true;\n  @Input() public maxNumberLength: number = 13;\n\n  public textMaskConfig: TextMaskConfig;\n\n  private textMaskInputElement: any;\n  private inputElement: HTMLInputElement;\n\n  /** Whether the user is creating a composition string (IME events). */\n  private composing: boolean = false;\n\n  constructor(\n    private renderer: Renderer2,\n    private elementRef: ElementRef,\n    @Inject(PLATFORM_ID) private platformId: object,\n    @Optional()\n    @Inject(COMPOSITION_BUFFER_MODE)\n    private compositionMode: boolean,\n  ) {\n    if (this.compositionMode == null) {\n      this.compositionMode = !this.isAndroid();\n    }\n  }\n\n  public onChange = (_: any) => {\n    // implement\n  };\n\n  public onTouched = () => {\n    // implement\n  };\n\n  ngOnInit(): void {\n    this.setupMask(true);\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this.setupMask(true);\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  }\n\n  @HostListener('blur')\n  onBlur(): void {\n    this.onTouched();\n  }\n\n  writeValue(value: any): void {\n    this.setupMask();\n\n    // set the initial value for cases where the mask is disabled\n    const normalizedValue = value == null ? '' : value;\n    this.renderer.setProperty(this.inputElement, 'value', normalizedValue);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value);\n    }\n  }\n\n  registerOnChange(fn: (_: any) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.renderer.setProperty(\n      this.elementRef.nativeElement,\n      'disabled',\n      isDisabled,\n    );\n  }\n\n  @HostListener('input', ['$event.target.value'])\n  handleInput(value: string): void {\n    if (!this.compositionMode || (this.compositionMode && !this.composing)) {\n      this.setupMask();\n\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value);\n\n        // get the updated value\n        value = this.inputElement.value;\n\n        if (this.clean) {\n          this.onChange(clean(value));\n        } else {\n          this.onChange(value);\n        }\n      }\n    }\n  }\n\n  setupMask(create: boolean = false): void {\n    this.textMaskConfig = {\n      mask: mask(this.maxNumberLength),\n      guide: false,\n      placeholderChar: '_',\n      pipe: undefined,\n      keepCharPositions: false,\n    };\n    if (!this.inputElement) {\n      if (this.elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this.elementRef.nativeElement;\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this.elementRef.nativeElement.getElementsByTagName(\n          'INPUT',\n        )[0];\n      }\n    }\n\n    if (this.inputElement && create) {\n      this.textMaskInputElement = createTextMaskInputElement(\n        Object.assign({ inputElement: this.inputElement }, this.textMaskConfig),\n      );\n    }\n  }\n\n  @HostListener('compositionstart')\n  compositionStart(): void {\n    this.composing = true;\n  }\n\n  @HostListener('compositionend', ['$event.target.value'])\n  compositionEnd(value: any): void {\n    this.composing = false;\n    // tslint:disable-next-line: no-unused-expression\n    this.compositionMode && this.handleInput(value);\n  }\n\n  /**\n   * We must check whether the agent is Android because composition events\n   * behave differently between iOS and Android.\n   */\n  private isAndroid(): boolean {\n    if (\n      isPlatformBrowser(this.platformId) &&\n      window &&\n      (window as any).navigator\n    ) {\n      const userAgent = window.navigator.userAgent;\n      return /android (\\d+)/.test(userAgent.toLowerCase());\n    }\n\n    return false;\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport { conformToMask } from '../mask/conform-to-mask.function';\nimport { mask } from './utils';\n\n@Pipe({\n  name: 'cntMaskPhone',\n})\nexport class PhoneMaskPipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) {\n      return '';\n    }\n\n    return conformToMask(value, mask(), { guide: false }).conformedValue;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { TextMaskModule } from './angular-2-text-mask.module';\nimport { CardExpirationPipe } from './cc/card-expiration.pipe';\nimport { CCCvcFormatDirective } from './cc/directives/cc-cvc-format.directive';\nimport { CCExpiryFormatDirective } from './cc/directives/cc-expiry-format.directive';\nimport { CCNumberFormatDirective } from './cc/directives/cc-number-format.directive';\nimport { PhoneMaskDirective } from './phone/phone-mask.directive';\nimport { PhoneMaskPipe } from './phone/phone-mask.pipe';\n\n@NgModule({\n  imports: [TextMaskModule],\n  declarations: [\n    CCNumberFormatDirective,\n    CCExpiryFormatDirective,\n    CCCvcFormatDirective,\n    CardExpirationPipe,\n    PhoneMaskDirective,\n    PhoneMaskPipe,\n  ],\n  exports: [\n    CCNumberFormatDirective,\n    CCExpiryFormatDirective,\n    CCCvcFormatDirective,\n    CardExpirationPipe,\n    PhoneMaskDirective,\n    PhoneMaskPipe,\n  ],\n  providers: [CardExpirationPipe, PhoneMaskPipe],\n})\nexport class CntMasksModule {}\n","import { Directive, forwardRef } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\n\n// @dynamic\n@Directive({\n  exportAs: 'cntMaskPhone',\n  providers: [\n    {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => PhoneMaskDirectiveMock),\n    },\n  ],\n  selector: '[cntMaskPhone]',\n})\nexport class PhoneMaskDirectiveMock {}\n","import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'cntMaskPhone',\n})\nexport class PhoneMaskPipeMock implements PipeTransform {\n  transform(value: string): string {\n    return value;\n  }\n}\n"]}