{"version":3,"file":"cnt-masks.js","sources":["../../../projects/cnt-masks/src/lib/cc/card-expiration.pipe.ts","../../../projects/cnt-masks/src/lib/cc/card-expiration.pipe.mock.ts","../../../projects/cnt-masks/src/lib/cc/payment.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-cvc-format.directive.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-cvc-format.directive.mock.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-expiry-format.directive.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-expiry-format.directive.mock.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-number-format.directive.ts","../../../projects/cnt-masks/src/lib/cc/directives/cc-number-format.directive.mock.ts","../../../projects/cnt-masks/src/lib/cc/validators/credit-card.validator.ts","../../../projects/cnt-masks/src/lib/mask/adjust-caret-position.function.ts","../../../projects/cnt-masks/src/lib/mask/conform-to-mask.function.ts","../../../projects/cnt-masks/src/lib/mask/create-text-mask-input-element.function.ts","../../../projects/cnt-masks/src/lib/angular-2-text-mask.module.ts","../../../projects/cnt-masks/src/lib/phone/utils.ts","../../../projects/cnt-masks/src/lib/phone/phone-mask.directive.ts","../../../projects/cnt-masks/src/lib/phone/phone-mask.pipe.ts","../../../projects/cnt-masks/src/lib/cnt-masks.module.ts","../../../projects/cnt-masks/src/lib/phone/phone-mask.directive.mock.ts","../../../projects/cnt-masks/src/lib/phone/phone-mask.pipe.mock.ts","../../../projects/cnt-masks/src/public-api.ts","../../../projects/cnt-masks/src/cnt-masks.ts"],"sourcesContent":["import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'cardExpiration',\n})\nexport class CardExpirationPipe implements PipeTransform {\n  transform(value: string): string {\n    if (typeof value !== 'number') {\n      value = value + '';\n    }\n\n    if (typeof value !== 'string') {\n      return value;\n    }\n\n    if (value.length === 3) {\n      value = `0${value}`;\n    }\n\n    return `${value.substring(0, 2)}/${value.substring(2)}`;\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'cardExpiration',\n})\nexport class CardExpirationPipeMock implements PipeTransform {\n  transform(value: string): string {\n    return value;\n  }\n}\n","/**\n * Based on:\n * Copyright (c) 2014 Jesse Pollak\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH TH\n */\ninterface ICardObject {\n  type: string;\n  pattern: RegExp;\n  format: RegExp;\n  length: number[];\n  cvcLength: number[];\n  luhn: boolean;\n}\n\nlet cards: ICardObject[];\nlet defaultFormat;\n\nconst indexOf =\n  [].indexOf ||\n  function (this: any[], item: any): number {\n    for (let i = 0, l = this.length; i < l; i++) {\n      if (i in this && this[i] === item) {\n        return i;\n      }\n    }\n    return -1;\n  };\n\ndefaultFormat = /(\\d{1,4})/g;\n\ncards = [\n  {\n    type: 'amex',\n    pattern: /^3[47]/,\n    format: /(\\d{1,4})(\\d{1,6})?(\\d{1,5})?/,\n    length: [15],\n    cvcLength: [4],\n    luhn: true,\n  },\n  {\n    type: 'dankort',\n    pattern: /^5019/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'hipercard',\n    pattern: /^(384100|384140|384160|606282|637095|637568|60(?!11))/,\n    format: defaultFormat,\n    length: [14, 15, 16, 17, 18, 19],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'dinersclub',\n    pattern: /^(36|38|30[0-5])/,\n    format: /(\\d{1,4})(\\d{1,6})?(\\d{1,4})?/,\n    length: [14],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'discover',\n    pattern: /^(6011|65|64[4-9]|622)/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'jcb',\n    pattern: /^35/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'laser',\n    pattern: /^(6706|6771|6709)/,\n    format: defaultFormat,\n    length: [16, 17, 18, 19],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'maestro',\n    pattern: /^(5018|5020|5038|6304|6703|6708|6759|676[1-3])/,\n    format: defaultFormat,\n    length: [12, 13, 14, 15, 16, 17, 18, 19],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'mastercard',\n    pattern: /^(5[1-5]|677189)|^(222[1-9]|2[3-6]\\d{2}|27[0-1]\\d|2720)/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'unionpay',\n    pattern: /^62/,\n    format: defaultFormat,\n    length: [16, 17, 18, 19],\n    cvcLength: [3],\n    luhn: false,\n  },\n  {\n    type: 'visaelectron',\n    pattern: /^4(026|17500|405|508|844|91[37])/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'elo',\n    // tslint:disable-next-line:max-line-length\n    pattern: /^(4011(78|79)|43(1274|8935)|45(1416|7393|763(1|2))|50(4175|6699|67[0-7][0-9]|9000)|627780|63(6297|6368)|650(03([^4])|04([0-9])|05(0|1)|4(0[5-9]|3[0-9]|8[5-9]|9[0-9])|5([0-2][0-9]|3[0-8])|9([2-6][0-9]|7[0-8])|541|700|720|901)|651652|655000|655021)/,\n    format: defaultFormat,\n    length: [16],\n    cvcLength: [3],\n    luhn: true,\n  },\n  {\n    type: 'visa',\n    pattern: /^4/,\n    format: defaultFormat,\n    length: [13, 16, 19],\n    cvcLength: [3],\n    luhn: true,\n  },\n];\n\nfunction cardFromNumber(num: string): any {\n  let card;\n  let i;\n  let len;\n  const numString = (num + '').replace(/\\D/g, '');\n  for (i = 0, len = cards.length; i < len; i++) {\n    card = cards[i];\n    if (card.pattern.test(numString)) {\n      return card;\n    }\n  }\n\n  return;\n}\n\nfunction cardFromType(type: string): any {\n  let card;\n  let i;\n  let len;\n  for (i = 0, len = cards.length; i < len; i++) {\n    card = cards[i];\n    if (card.type === type) {\n      return card;\n    }\n  }\n\n  return;\n}\n\nfunction luhnCheck(num: string): boolean {\n  let digits;\n  let odd = true;\n  let sum = 0;\n\n  digits = (num + '').split('').reverse();\n\n  digits.forEach((digitString) => {\n    let digit = parseInt(digitString, 10);\n    odd = !odd;\n    if (odd) {\n      digit *= 2;\n    }\n    if (digit > 9) {\n      digit -= 9;\n    }\n    return (sum += digit);\n  });\n\n  return sum % 10 === 0;\n}\n\nfunction hasTextSelected(target?: EventTarget): boolean {\n  let e;\n  try {\n    // If some text is selected\n    if (\n      target &&\n      (target as any).selectionStart != null &&\n      (target as any).selectionStart !== (target as any).selectionEnd\n    ) {\n      return true;\n    }\n  } catch (error) {\n    e = error;\n  }\n\n  return false;\n}\n\nfunction qjon(\n  element: Element | any,\n  eventName: string,\n  callback: (e: Event) => void\n): any {\n  if (element.length) {\n    // handle multiple elements\n    for (const el of Array.from(element)) {\n      qjon(el, eventName, callback);\n    }\n    return;\n  }\n\n  if (eventName.match(' ')) {\n    // handle multiple event attachment\n    for (const multiEventName of Array.from(eventName.split(' '))) {\n      qjon(element, multiEventName, callback);\n    }\n    return;\n  }\n\n  if (element.addEventListener) {\n    return element.addEventListener(eventName, callback, false);\n  }\n\n  if (element.attachEvent) {\n    eventName = 'on' + eventName;\n    return element.attachEvent(eventName, callback);\n  }\n\n  element['on' + eventName] = callback;\n}\n\nfunction trigger(el: Element, name: string, data?: any): boolean {\n  let ev;\n\n  try {\n    ev = new CustomEvent(name, { detail: data });\n  } catch (e) {\n    ev = document.createEvent('CustomEvent');\n    // jsdom doesn't have initCustomEvent, so we need this check for\n    // testing\n    if (ev.initCustomEvent) {\n      ev.initCustomEvent(name, true, true, data);\n    } else {\n      (ev as any).initEvent(name, true, true, data);\n    }\n  }\n\n  return el.dispatchEvent(ev);\n}\n\n// Public\n// @dynamic\nexport class Payment {\n  public static fns = {\n    cardExpiryVal: (value: string) => {\n      let month;\n      let prefix;\n      let year;\n      let ref;\n\n      value = value.replace(/\\s/g, '');\n      (ref = value.split('/', 2)), (month = ref[0]), (year = ref[1]);\n\n      // Allow for year shortcut\n      if ((year != null ? year.length : void 0) === 2 && /^\\d+$/.test(year)) {\n        prefix = new Date().getFullYear();\n        prefix = prefix.toString().slice(0, 2);\n        year = prefix + year;\n      }\n\n      return {\n        month,\n        year,\n      };\n    },\n    validateCardNumber: (num: string) => {\n      let card;\n      let ref;\n\n      num = (num + '').replace(/\\s+|-/g, '');\n      if (!/^\\d+$/.test(num)) {\n        return false;\n      }\n\n      card = cardFromNumber(num);\n      if (!card) {\n        return false;\n      }\n\n      return (\n        ((ref = num.length), indexOf.call(card.length, ref) >= 0) &&\n        (card.luhn === false || luhnCheck(num))\n      );\n    },\n    validateCardExpiry: (month: string, year: string) => {\n      // Allow passing an object\n      let currentTime;\n      let expiry;\n      let prefix;\n      let ref1;\n\n      if (typeof month === 'string' && indexOf.call(month, '/') >= 0) {\n        (ref1 = Payment.fns.cardExpiryVal(month)),\n          (month = ref1.month),\n          (year = ref1.year);\n      }\n\n      if (!(month && year)) {\n        return false;\n      }\n\n      month = month.trim();\n      year = year.trim();\n\n      if (!/^\\d+$/.test(month)) {\n        return false;\n      }\n      if (!/^\\d+$/.test(year)) {\n        return false;\n      }\n\n      const monthInt = parseInt(month, 10);\n\n      if (!(monthInt && monthInt <= 12)) {\n        return false;\n      }\n\n      if (year.length === 2) {\n        prefix = new Date().getFullYear();\n        prefix = prefix.toString().slice(0, 2);\n        year = prefix + year;\n      }\n\n      expiry = new Date(parseInt(year, 10), monthInt);\n      currentTime = new Date();\n\n      // Months start from 0 in JavaScript\n      expiry.setMonth(expiry.getMonth() - 1);\n\n      // The cc expires at the end of the month,\n      // so we need to make the expiry the first day\n      // of the month after\n      expiry.setMonth(expiry.getMonth() + 1, 1);\n\n      return expiry > currentTime;\n    },\n    validateCardCVC: (cvc: string, type?: string) => {\n      let ref;\n      let ref1;\n\n      cvc = cvc.trim();\n      if (!/^\\d+$/.test(cvc)) {\n        return false;\n      }\n\n      if (type && cardFromType(type)) {\n        // Check against a explicit card type\n        ref1 = cardFromType(type);\n        return (\n          (ref = cvc.length),\n          indexOf.call(ref1 != null ? ref1.cvcLength : void 0, ref) >= 0\n        );\n      } else {\n        // Check against all types\n        return cvc.length >= 3 && cvc.length <= 4;\n      }\n    },\n    cardType: (num: string) => {\n      if (!num) {\n        return null;\n      }\n      const ref = cardFromNumber(num);\n      return (ref != null ? ref.type : void 0) || null;\n    },\n    formatCardNumber: (num: string) => {\n      let card;\n      let groups;\n      let upperLength;\n\n      card = cardFromNumber(num);\n      if (!card) {\n        return num;\n      }\n\n      upperLength = card.length[card.length.length - 1];\n\n      num = num.replace(/\\D/g, '');\n      num = num.slice(0, upperLength);\n\n      if (card.format.global) {\n        const ref = num.match(card.format);\n        return ref != null ? ref.join(' ') : void 0;\n      } else {\n        groups = card.format.exec(num);\n        if (groups == null) {\n          return;\n        }\n        groups.shift();\n        groups = groups.filter((n) => n); // Filter empty groups\n        return groups.join(' ');\n      }\n    },\n  };\n\n  public static restrictNumeric(el: Element): any {\n    return qjon(el, 'keypress', restrictNumeric);\n  }\n\n  public static formatCardCVC(el: Element): Element {\n    Payment.restrictNumeric(el);\n    qjon(el, 'keypress', restrictCVC);\n    return el;\n  }\n\n  public static formatCardExpiry(el: Element): Element {\n    let month;\n    let year;\n\n    Payment.restrictNumeric(el);\n    if ((el as any).length && (el as any).length === 2) {\n      (month = (el as any)[0]), (year = (el as any)[1]);\n      this.formatCardExpiryMultiple(month, year);\n    } else {\n      qjon(el, 'keypress', restrictCombinedExpiry);\n      qjon(el, 'keypress', formatExpiry);\n      qjon(el, 'keypress', formatForwardSlash);\n      qjon(el, 'keypress', formatForwardExpiry);\n      qjon(el, 'keydown', formatBackExpiry);\n    }\n    return el;\n  }\n\n  public static formatCardExpiryMultiple(month: string, year: string): any {\n    qjon(month, 'keypress', restrictMonthExpiry);\n    qjon(month, 'keypress', formatMonthExpiry);\n    return qjon(year, 'keypress', restrictYearExpiry);\n  }\n\n  public static formatCardNumber(el: Element, maxLength?: number): Element {\n    Payment.restrictNumeric(el);\n    qjon(el, 'keypress', restrictCardNumber(maxLength));\n    qjon(el, 'keypress', formatCardNumber(maxLength));\n    qjon(el, 'keydown', formatBackCardNumber);\n    qjon(el, 'keyup blur', setCardType);\n    qjon(el, 'paste', reFormatCardNumber);\n    qjon(el, 'input', reFormatCardNumber);\n    return el;\n  }\n}\n// Private\n\n// Format Card Number\n\nfunction reFormatCardNumber(e: Event): number {\n  return setTimeout(() => {\n    let value;\n    const target = e.target as HTMLDataElement;\n\n    if (!target) {\n      return;\n    }\n\n    value = target.value;\n    value = Payment.fns.formatCardNumber(value);\n    if (value) {\n      target.value = value;\n    }\n    return trigger(target, 'change');\n  });\n}\n\nfunction formatCardNumber(maxLength?: number): (event) => boolean {\n  return (e: Event) => {\n    // Only format if input is a number\n    let card;\n    let digit;\n    let i;\n    let length;\n    let re;\n    let target;\n    let upperLength;\n    let upperLengths;\n    let value;\n    let j;\n    let len;\n    digit = String.fromCharCode((e as any).which);\n    if (!/^\\d+$/.test(digit)) {\n      return;\n    }\n\n    target = e.target as HTMLDataElement;\n    value = target.value;\n    card = cardFromNumber(value + digit);\n    length = (value.replace(/\\D/g, '') + digit).length;\n\n    upperLengths = [16];\n    if (card) {\n      upperLengths = card.length;\n    }\n    if (maxLength) {\n      upperLengths = upperLengths.filter((x) => x <= maxLength);\n    }\n\n    // Return if an upper length has been reached\n    for (i = j = 0, len = upperLengths.length; j < len; i = ++j) {\n      upperLength = upperLengths[i];\n      if (length >= upperLength && upperLengths[i + 1]) {\n        continue;\n      }\n      if (length >= upperLength) {\n        return;\n      }\n    }\n\n    // Return if focus isn't at the end of the text\n    if (hasTextSelected(target)) {\n      return;\n    }\n\n    if (card && card.type === 'amex') {\n      // Amex cards are formatted differently\n      re = /^(\\d{4}|\\d{4}\\s\\d{6})$/;\n    } else {\n      re = /(?:^|\\s)(\\d{4})$/;\n    }\n\n    // If '4242' + 4\n    if (re.test(value)) {\n      e.preventDefault();\n      target.value = value + ' ' + digit;\n      return trigger(target, 'change');\n    }\n\n    return;\n  };\n}\n\nfunction formatBackCardNumber(e: Event): boolean {\n  const target = e.target as HTMLDataElement;\n  const value = target.value;\n\n  if ((e as any).meta) {\n    return;\n  }\n\n  // Return unless backspacing\n  if ((e as any).which !== 8) {\n    return;\n  }\n\n  // Return if focus isn't at the end of the text\n  if (hasTextSelected(target)) {\n    return;\n  }\n\n  // Remove the trailing space\n  if (/\\d\\s$/.test(value)) {\n    e.preventDefault();\n    target.value = value.replace(/\\d\\s$/, '');\n    return trigger(target, 'change');\n  } else if (/\\s\\d?$/.test(value)) {\n    e.preventDefault();\n    target.value = value.replace(/\\s\\d?$/, '');\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\n// Format Expiry\n\nfunction formatExpiry(e: Event): boolean {\n  // Only format if input is a number\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const val = target.value + digit;\n\n  if (/^\\d$/.test(val) && val !== '0' && val !== '1') {\n    e.preventDefault();\n    target.value = '0' + val + ' / ';\n    return trigger(target, 'change');\n  } else if (/^\\d\\d$/.test(val)) {\n    e.preventDefault();\n    target.value = val + ' / ';\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\nfunction formatMonthExpiry(e: Event): boolean {\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const val = target.value + digit;\n\n  if (/^\\d$/.test(val) && val !== '0' && val !== '1') {\n    e.preventDefault();\n    target.value = '0' + val;\n    return trigger(target, 'change');\n  } else if (/^\\d\\d$/.test(val)) {\n    e.preventDefault();\n    target.value = val;\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\nfunction formatForwardExpiry(e: Event): boolean {\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const val = target.value;\n\n  if (/^\\d\\d$/.test(val)) {\n    target.value = val + ' / ';\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\nfunction formatForwardSlash(e: Event): boolean {\n  const slash = String.fromCharCode((e as any).which);\n  if (slash !== '/') {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const val = target.value;\n\n  if (/^\\d$/.test(val) && val !== '0') {\n    target.value = '0' + val + ' / ';\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\nfunction formatBackExpiry(e: Event): boolean {\n  // If shift+backspace is pressed\n  if ((e as any).metaKey) {\n    return;\n  }\n\n  const target = e.target as HTMLDataElement;\n  const value = target.value;\n\n  // Return unless backspacing\n  if ((e as any).which !== 8) {\n    return;\n  }\n\n  // Return if focus isn't at the end of the text\n  if (hasTextSelected(target)) {\n    return;\n  }\n\n  // Remove the trailing space\n  if (/\\d(\\s|\\/)+$/.test(value)) {\n    e.preventDefault();\n    target.value = value.replace(/\\d(\\s|\\/)*$/, '');\n    return trigger(target, 'change');\n  } else if (/\\s\\/\\s?\\d?$/.test(value)) {\n    e.preventDefault();\n    target.value = value.replace(/\\s\\/\\s?\\d?$/, '');\n    return trigger(target, 'change');\n  }\n\n  return;\n}\n\n//  Restrictions\n\nfunction restrictNumeric(e: Event): boolean {\n  // Key event is for a browser shortcut\n  let input;\n  if ((e as any).metaKey || (e as any).ctrlKey) {\n    return true;\n  }\n\n  // If keycode is a space\n  if ((e as any).which === 32) {\n    e.preventDefault();\n    return false;\n  }\n\n  // If keycode is a special char (WebKit)\n  if ((e as any).which === 0) {\n    return true;\n  }\n\n  // If char is a special char (Firefox)\n  if ((e as any).which < 33) {\n    return true;\n  }\n\n  input = String.fromCharCode((e as any).which);\n\n  // Char is a number or a space\n  if (!/[\\d\\s]/.test(input)) {\n    e.preventDefault();\n    return false;\n  }\n}\n\nfunction restrictCardNumber(maxLength?: number): (Event) => void {\n  return (e: Event) => {\n    let length;\n\n    const target = e.target as HTMLDataElement;\n    const digit = String.fromCharCode((e as any).which);\n    if (!/^\\d+$/.test(digit)) {\n      return;\n    }\n\n    if (hasTextSelected(target)) {\n      return;\n    }\n\n    // Restrict number of digits\n    const value = (target.value + digit).replace(/\\D/g, '');\n    const card = cardFromNumber(value);\n\n    length = 16;\n    if (card) {\n      length = card.length[card.length.length - 1];\n    }\n    if (maxLength) {\n      length = Math.min(length, maxLength);\n    }\n\n    if (!(value.length <= length)) {\n      return e.preventDefault();\n    }\n  };\n}\n\nfunction restrictExpiry(e: Event, length: number): void {\n  let value;\n  const target = e.target as HTMLDataElement;\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  if (hasTextSelected(target)) {\n    return;\n  }\n\n  value = target.value + digit;\n  value = value.replace(/\\D/g, '');\n\n  if (value.length > length) {\n    return e.preventDefault();\n  }\n}\n\nfunction restrictCombinedExpiry(e: Event): void {\n  return restrictExpiry(e, 6);\n}\n\nfunction restrictMonthExpiry(e: Event): void {\n  return restrictExpiry(e, 2);\n}\n\nfunction restrictYearExpiry(e: Event): void {\n  return restrictExpiry(e, 4);\n}\n\nfunction restrictCVC(e: Event): void {\n  const target = e.target as HTMLDataElement;\n  const digit = String.fromCharCode((e as any).which);\n  if (!/^\\d+$/.test(digit)) {\n    return;\n  }\n\n  if (hasTextSelected(target)) {\n    return;\n  }\n\n  const val = target.value + digit;\n  if (!(val.length <= 4)) {\n    return e.preventDefault();\n  }\n}\n\nfunction setCardType(e: Event): boolean {\n  const target = e.target as HTMLDataElement;\n  const val = target.value;\n  const cardType = Payment.fns.cardType(val) || 'unknown';\n\n  if (target && target.classList && !target.classList.contains(cardType)) {\n    target.classList.add('unknown');\n    cards.forEach((card) => target.classList.remove(card.type));\n\n    target.classList.add(cardType);\n\n    if (cardType !== 'unknown') {\n      if (target.classList.contains('identified')) {\n        target.classList.add('identified');\n      }\n    } else {\n      target.classList.remove('identified');\n    }\n    return trigger(target, 'payment.cardType', cardType);\n  }\n\n  return;\n}\n","import { Directive, ElementRef } from '@angular/core';\n\nimport { Payment } from '../payment';\n\n@Directive({\n  selector: '[cntMaskCCCvc]',\n})\nexport class CCCvcFormatDirective {\n  constructor(private el: ElementRef) {\n    const element = this.el.nativeElement;\n\n    // call lib functions\n    Payment.formatCardCVC(element);\n    Payment.restrictNumeric(element);\n  }\n}\n","import { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[cntMaskCCCvc]',\n})\nexport class CCCvcFormatDirectiveMock {}\n","import { Directive, ElementRef } from '@angular/core';\n\nimport { Payment } from '../payment';\n\n@Directive({\n  selector: '[cntMaskCCExp]',\n})\nexport class CCExpiryFormatDirective {\n  constructor(private el: ElementRef) {\n    const element = this.el.nativeElement;\n\n    // call lib functions\n    Payment.formatCardExpiry(element);\n    Payment.restrictNumeric(element);\n  }\n}\n","import { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[cntMaskCCExp]',\n})\nexport class CCExpiryFormatDirectiveMock {}\n","import { Directive, ElementRef, HostListener, Renderer2 } from '@angular/core';\nimport { Payment } from '../payment';\n\n@Directive({\n  selector: '[cntMaskCCNum]',\n})\nexport class CCNumberFormatDirective {\n  cardType: string | null;\n\n  constructor(private renderer: Renderer2, private el: ElementRef) {\n    const element = this.el.nativeElement;\n    this.cardType = '';\n\n    // call lib functions\n    Payment.formatCardNumber(element);\n    Payment.restrictNumeric(element);\n  }\n\n  @HostListener('keypress', ['$event'])\n  onKeypress(e: Event): void {\n    const element = this.el.nativeElement;\n    const elementValue = element.value;\n\n    this.cardType = Payment.fns.cardType(elementValue);\n\n    if (this.cardType && this.cardType !== '') {\n      this.renderer.removeClass(element, this.cardType);\n    } else {\n      this.cardType = '';\n    }\n  }\n}\n","import { Directive } from '@angular/core';\n\n@Directive({\n  selector: '[cntMaskCCNum]',\n})\nexport class CCNumberFormatDirectiveMock {}\n","import { FormControl, ValidationErrors } from '@angular/forms';\nimport { Payment } from '../payment';\n\nexport class CreditCardValidator {\n  /**\n   * Validates a cc number\n   */\n  static validateCardNumber(control: FormControl): ValidationErrors {\n    if (control) {\n      const isValid = Payment.fns.validateCardNumber(control.value);\n\n      if (!isValid) {\n        return {\n          cardNumber: true,\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validates the expiry date.\n   * Breaks exp by \"/\" string and assumes that first array entry is month and second year\n   * Also removes any spaces\n   */\n  static validateCardExpiry(control: FormControl): ValidationErrors {\n    if (control) {\n      const controlValue = control.value.split('/');\n      let isValid = false;\n\n      if (controlValue.length > 1) {\n        const month = controlValue[0].replace(/^\\s+|\\s+$/g, '');\n        const year = controlValue[1].replace(/^\\s+|\\s+$/g, '');\n\n        isValid = Payment.fns.validateCardExpiry(month, year);\n      }\n\n      if (!isValid) {\n        return {\n          cardExpiry: true,\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Validates cards CVC\n   * Also removes any spaces\n   */\n  static validateCardCvc(control: FormControl): ValidationErrors {\n    if (control) {\n      const isValid = Payment.fns.validateCardCVC(control.value);\n\n      if (!isValid) {\n        return {\n          cardCvc: true,\n        };\n      }\n    }\n\n    return null;\n  }\n}\n","const defaultArray = [];\nconst emptyString = '';\n\nexport function adjustCaretPosition({\n  previousConformedValue = emptyString,\n  previousPlaceholder = emptyString,\n  currentCaretPosition = 0,\n  conformedValue,\n  rawValue,\n  placeholderChar,\n  placeholder,\n  indexesOfPipedChars = defaultArray,\n  caretTrapIndexes = defaultArray,\n}: any): number {\n  if (currentCaretPosition === 0 || !rawValue.length) {\n    return 0;\n  }\n\n  // Store lengths for faster performance?\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const conformedValueLength = conformedValue.length;\n\n  // This tells us how long the edit is. If user modified input from `(2__)` to `(243__)`,\n  // we know the user in this instance pasted two characters\n  const editLength = rawValueLength - previousConformedValueLength;\n\n  // If the edit length is positive, that means the user is adding characters, not deleting.\n  const isAddition = editLength > 0;\n\n  // This is the first raw value the user entered that needs to be conformed to mask\n  const isFirstRawValue = previousConformedValueLength === 0;\n\n  // A partial multi-character edit happens when the user makes a partial selection in their\n  // input and edits that selection. That is going from `(123) 432-4348` to `() 432-4348` by\n  // selecting the first 3 digits and pressing backspace.\n  //\n  // Such cases can also happen when the user presses the backspace while holding down the ALT\n  // key.\n  const isPartialMultiCharEdit =\n    editLength > 1 && !isAddition && !isFirstRawValue;\n\n  // This algorithm doesn't support all cases of multi-character edits, so we just return\n  // the current caret position.\n  //\n  // This works fine for most cases.\n  if (isPartialMultiCharEdit) {\n    return currentCaretPosition;\n  }\n\n  // For a mask like (111), if the `previousConformedValue` is (1__) and user attempts to enter\n  // `f` so the `rawValue` becomes (1f__), the new `conformedValue` would be (1__), which is the\n  // same as the original `previousConformedValue`. We handle this case differently for caret\n  // positioning.\n  const possiblyHasRejectedChar =\n    isAddition &&\n    (previousConformedValue === conformedValue ||\n      conformedValue === placeholder);\n\n  let startingSearchIndex = 0;\n  let trackRightCharacter;\n  let targetChar;\n\n  if (possiblyHasRejectedChar) {\n    startingSearchIndex = currentCaretPosition - editLength;\n  } else {\n    // At this point in the algorithm, we want to know where the caret is right before the raw input\n    // has been conformed, and then see if we can find that same spot in the conformed input.\n    //\n    // We do that by seeing what character lies immediately before the caret, and then look for that\n    // same character in the conformed input and place the caret there.\n\n    // First, we need to normalize the inputs so that letter capitalization between raw input and\n    // conformed input wouldn't matter.\n    const normalizedConformedValue = conformedValue.toLowerCase();\n    const normalizedRawValue = rawValue.toLowerCase();\n\n    // Then we take all characters that come before where the caret currently is.\n    const leftHalfChars = normalizedRawValue\n      .substr(0, currentCaretPosition)\n      .split(emptyString);\n\n    // Now we find all the characters in the left half that exist in the conformed input\n    // This step ensures that we don't look for a character that was filtered out or rejected by `conformToMask`.\n    const intersection = leftHalfChars.filter(\n      (char) => normalizedConformedValue.indexOf(char) !== -1,\n    );\n\n    // The last character in the intersection is the character we want to look for in the conformed\n    // value and the one we want to adjust the caret close to\n    targetChar = intersection[intersection.length - 1];\n\n    // Calculate the number of mask characters in the previous placeholder\n    // from the start of the string up to the place where the caret is\n    const previousLeftMaskChars = previousPlaceholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter((char) => char !== placeholderChar).length;\n\n    // Calculate the number of mask characters in the current placeholder\n    // from the start of the string up to the place where the caret is\n    const leftMaskChars = placeholder\n      .substr(0, intersection.length)\n      .split(emptyString)\n      .filter((char) => char !== placeholderChar).length;\n\n    // Has the number of mask characters up to the caret changed?\n    const masklengthChanged = leftMaskChars !== previousLeftMaskChars;\n\n    // Detect if `targetChar` is a mask character and has moved to the left\n    const targetIsMaskMovingLeft =\n      previousPlaceholder[intersection.length - 1] !== undefined &&\n      placeholder[intersection.length - 2] !== undefined &&\n      previousPlaceholder[intersection.length - 1] !== placeholderChar &&\n      previousPlaceholder[intersection.length - 1] !==\n        placeholder[intersection.length - 1] &&\n      previousPlaceholder[intersection.length - 1] ===\n        placeholder[intersection.length - 2];\n\n    // If deleting and the `targetChar` `is a mask character and `masklengthChanged` is true\n    // or the mask is moving to the left, we can't use the selected `targetChar` any longer\n    // if we are not at the end of the string.\n    // In this case, change tracking strategy and track the character to the right of the caret.\n    if (\n      !isAddition &&\n      (masklengthChanged || targetIsMaskMovingLeft) &&\n      previousLeftMaskChars > 0 &&\n      placeholder.indexOf(targetChar) > -1 &&\n      rawValue[currentCaretPosition] !== undefined\n    ) {\n      trackRightCharacter = true;\n      targetChar = rawValue[currentCaretPosition];\n    }\n\n    // It is possible that `targetChar` will appear multiple times in the conformed value.\n    // We need to know not to select a character that looks like our target character from the placeholder or\n    // the piped characters, so we inspect the piped characters and the placeholder to see if they contain\n    // characters that match our target character.\n\n    // If the `conformedValue` got piped, we need to know which characters were piped in so that when we look for\n    // our `targetChar`, we don't select a piped char by mistake\n    const pipedChars = indexesOfPipedChars.map(\n      (index) => normalizedConformedValue[index],\n    );\n\n    // We need to know how many times the `targetChar` occurs in the piped characters.\n    const countTargetCharInPipedChars = pipedChars.filter(\n      (char) => char === targetChar,\n    ).length;\n\n    // We need to know how many times it occurs in the intersection\n    const countTargetCharInIntersection = intersection.filter(\n      (char) => char === targetChar,\n    ).length;\n\n    // We need to know if the placeholder contains characters that look like\n    // our `targetChar`, so we don't select one of those by mistake.\n    const countTargetCharInPlaceholder = placeholder\n      .substr(0, placeholder.indexOf(placeholderChar))\n      .split(emptyString)\n      .filter(\n        (char, index) =>\n          // Check if `char` is the same as our `targetChar`, so we account for it\n          char === targetChar &&\n          // but also make sure that both the `rawValue` and placeholder don't have the same character at the same\n          // index because if they are equal, that means we are already counting those characters in\n          // `countTargetCharInIntersection`\n          rawValue[index] !== char,\n      ).length;\n\n    // The number of times we need to see occurrences of the `targetChar` before we know it is the one we're looking\n    // for is:\n    const requiredNumberOfMatches =\n      countTargetCharInPlaceholder +\n      countTargetCharInIntersection +\n      countTargetCharInPipedChars +\n      // The character to the right of the caret isn't included in `intersection`\n      // so add one if we are tracking the character to the right\n      (trackRightCharacter ? 1 : 0);\n\n    // Now we start looking for the location of the `targetChar`.\n    // We keep looping forward and store the index in every iteration. Once we have encountered\n    // enough occurrences of the target character, we break out of the loop\n    // If are searching for the second `1` in `1214`, `startingSearchIndex` will point at `4`.\n    let numberOfEncounteredMatches = 0;\n    for (let i = 0; i < conformedValueLength; i++) {\n      const conformedValueChar = normalizedConformedValue[i];\n\n      startingSearchIndex = i + 1;\n\n      if (conformedValueChar === targetChar) {\n        numberOfEncounteredMatches++;\n      }\n\n      if (numberOfEncounteredMatches >= requiredNumberOfMatches) {\n        break;\n      }\n    }\n  }\n\n  // At this point, if we simply return `startingSearchIndex` as the adjusted caret position,\n  // most cases would be handled. However, we want to fast forward or rewind the caret to the\n  // closest placeholder character if it happens to be in a non-editable spot. That's what the next\n  // logic is for.\n\n  // In case of addition, we fast forward.\n  if (isAddition) {\n    // We want to remember the last placeholder character encountered so that if the mask\n    // contains more characters after the last placeholder character, we don't forward the caret\n    // that far to the right. Instead, we stop it at the last encountered placeholder character.\n    let lastPlaceholderChar = startingSearchIndex;\n\n    for (let i = startingSearchIndex; i <= placeholderLength; i++) {\n      if (placeholder[i] === placeholderChar) {\n        lastPlaceholderChar = i;\n      }\n\n      if (\n        // If we're adding, we can position the caret at the next placeholder character.\n        placeholder[i] === placeholderChar ||\n        // If a caret trap was set by a mask function, we need to stop at the trap.\n        caretTrapIndexes.indexOf(i) !== -1 ||\n        // This is the end of the placeholder. We cannot move any further. Let's put the caret there.\n        i === placeholderLength\n      ) {\n        return lastPlaceholderChar;\n      }\n    }\n  } else {\n    // In case of deletion, we rewind.\n    if (trackRightCharacter) {\n      // Searching for the character that was to the right of the caret\n      // We start at `startingSearchIndex` - 1 because it includes one character extra to the right\n      for (let i = startingSearchIndex - 1; i >= 0; i--) {\n        // If tracking the character to the right of the cursor, we move to the left until\n        // we found the character and then place the caret right before it\n\n        if (\n          // `targetChar` should be in `conformedValue`, since it was in `rawValue`, just\n          // to the right of the caret\n          conformedValue[i] === targetChar ||\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i;\n        }\n      }\n    } else {\n      // Searching for the first placeholder or caret trap to the left\n\n      for (let i = startingSearchIndex; i >= 0; i--) {\n        // If we're deleting, we stop the caret right before the placeholder character.\n        // For example, for mask `(111) 11`, current conformed input `(456) 86`. If user\n        // modifies input to `(456 86`. That is, they deleted the `)`, we place the caret\n        // right after the first `6`\n\n        if (\n          // If we're deleting, we can position the caret right before the placeholder character\n          placeholder[i - 1] === placeholderChar ||\n          // If a caret trap was set by a mask function, we need to stop at the trap.\n          caretTrapIndexes.indexOf(i) !== -1 ||\n          // This is the beginning of the placeholder. We cannot move any further.\n          // Let's put the caret there.\n          i === 0\n        ) {\n          return i;\n        }\n      }\n    }\n  }\n}\n","export const defaultPlaceholderChar = '_';\n\nconst emptyArray = [];\nconst emptyString = '';\n\nfunction convertMaskToPlaceholder(\n  mask: any[] = emptyArray,\n  placeholderChar: string = defaultPlaceholderChar,\n): string {\n  if (!Array.isArray(mask)) {\n    throw new Error(\n      'Text-mask:convertMaskToPlaceholder; The mask property must be an array.',\n    );\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n        'that is not present in your mask as your placeholder character.\\n\\n' +\n        `The placeholder character that was received is: ${JSON.stringify(\n          placeholderChar,\n        )}\\n\\n` +\n        `The mask that was received is: ${JSON.stringify(mask)}`,\n    );\n  }\n\n  return mask\n    .map((char) => {\n      return char instanceof RegExp ? placeholderChar : char;\n    })\n    .join('');\n}\n\nconst strCaretTrap = '[]';\nexport function processCaretTraps(\n  mask: any[],\n): { maskWithoutCaretTraps: any; indexes: any[] } {\n  const indexes = [];\n\n  let indexOfCaretTrap;\n  while (\n    // tslint:disable-next-line: no-conditional-assignment\n    ((indexOfCaretTrap = mask.indexOf(strCaretTrap)), indexOfCaretTrap !== -1)\n  ) {\n    // eslint-disable-line\n    indexes.push(indexOfCaretTrap);\n\n    mask.splice(indexOfCaretTrap, 1);\n  }\n\n  return { maskWithoutCaretTraps: mask, indexes };\n}\n\nexport function conformToMask(\n  rawValue: string = emptyString,\n  mask: any[] | any = emptyArray,\n  config: any = {},\n): { conformedValue: string; meta: { someCharsRejected: boolean } } {\n  if (!Array.isArray(mask)) {\n    // If someone passes a function as the mask property, we should call the\n    // function to get the mask array - Normally this is handled by the\n    // `createTextMaskInputElement:update` function - this allows mask functions\n    // to be used directly with `conformToMask`\n    if (typeof mask === 'function') {\n      // call the mask function to get the mask array\n      mask = mask(rawValue, config);\n\n      // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n      // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask\n      mask = processCaretTraps(mask).maskWithoutCaretTraps;\n    } else {\n      throw new Error(\n        'Text-mask:conformToMask; The mask property must be an array.',\n      );\n    }\n  }\n\n  // These configurations tell us how to conform the mask\n  const {\n    guide = true,\n    previousConformedValue = emptyString,\n    placeholderChar = defaultPlaceholderChar,\n    placeholder = convertMaskToPlaceholder(mask, placeholderChar),\n    currentCaretPosition,\n    keepCharPositions,\n  } = config;\n\n  // The configs below indicate that the user wants the algorithm to work in *no guide* mode\n  const suppressGuide = guide === false && previousConformedValue !== undefined;\n\n  // Calculate lengths once for performance\n  const rawValueLength = rawValue.length;\n  const previousConformedValueLength = previousConformedValue.length;\n  const placeholderLength = placeholder.length;\n  const maskLength = mask.length;\n\n  // This tells us the number of edited characters and the direction in which they were edited (+/-)\n  const editDistance = rawValueLength - previousConformedValueLength;\n\n  // In *no guide* mode, we need to know if the user is trying to add a character or not\n  const isAddition = editDistance > 0;\n\n  // Tells us the index of the first change. For (438) 394-4938 to (38) 394-4938, that would be 1\n  const indexOfFirstChange =\n    currentCaretPosition + (isAddition ? -editDistance : 0);\n\n  // We're also gonna need the index of last change, which we can derive as follows...\n  const indexOfLastChange = indexOfFirstChange + Math.abs(editDistance);\n\n  // If `conformToMask` is configured to keep character positions, that is, for mask 111, previous value\n  // _2_ and raw value 3_2_, the new conformed value should be 32_, not 3_2 (default behavior). That's in the case of\n  // addition. And in the case of deletion, previous value _23, raw value _3, the new conformed string should be\n  // __3, not _3_ (default behavior)\n  //\n  // The next block of logic handles keeping character positions for the case of deletion. (Keeping\n  // character positions for the case of addition is further down since it is handled differently.)\n  // To do this, we want to compensate for all characters that were deleted\n  if (keepCharPositions === true && !isAddition) {\n    // We will be storing the new placeholder characters in this variable.\n    let compensatingPlaceholderChars = emptyString;\n\n    // For every character that was deleted from a placeholder position, we add a placeholder char\n    for (let i = indexOfFirstChange; i < indexOfLastChange; i++) {\n      if (placeholder[i] === placeholderChar) {\n        compensatingPlaceholderChars += placeholderChar;\n      }\n    }\n\n    // Now we trick our algorithm by modifying the raw value to make it contain additional placeholder characters\n    // That way when the we start laying the characters again on the mask, it will keep the non-deleted characters\n    // in their positions.\n    rawValue =\n      rawValue.slice(0, indexOfFirstChange) +\n      compensatingPlaceholderChars +\n      rawValue.slice(indexOfFirstChange, rawValueLength);\n  }\n\n  // Convert `rawValue` string to an array, and mark characters based on whether they are newly added or have\n  // existed in the previous conformed value. Identifying new and old characters is needed for `conformToMask`\n  // to work if it is configured to keep character positions.\n  const rawValueArr = rawValue.split(emptyString).map((char, i) => ({\n    char,\n    isNew: i >= indexOfFirstChange && i < indexOfLastChange,\n  }));\n\n  // The loop below removes masking characters from user input. For example, for mask\n  // `00 (111)`, the placeholder would be `00 (___)`. If user input is `00 (234)`, the loop below\n  // would remove all characters but `234` from the `rawValueArr`. The rest of the algorithm\n  // then would lay `234` on top of the available placeholder positions in the mask.\n  for (let i = rawValueLength - 1; i >= 0; i--) {\n    const { char } = rawValueArr[i];\n\n    if (char !== placeholderChar) {\n      const shouldOffset =\n        i >= indexOfFirstChange && previousConformedValueLength === maskLength;\n\n      if (char === placeholder[shouldOffset ? i - editDistance : i]) {\n        rawValueArr.splice(i, 1);\n      }\n    }\n  }\n\n  // This is the variable that we will be filling with characters as we figure them out\n  // in the algorithm below\n  let conformedValue = emptyString;\n  let someCharsRejected = false;\n\n  // Ok, so first we loop through the placeholder looking for placeholder characters to fill up.\n  placeholderLoop: for (let i = 0; i < placeholderLength; i++) {\n    const charInPlaceholder = placeholder[i];\n\n    // We see one. Let's find out what we can put in it.\n    if (charInPlaceholder === placeholderChar) {\n      // But before that, do we actually have any user characters that need a place?\n      if (rawValueArr.length > 0) {\n        // We will keep chipping away at user input until either we run out of characters\n        // or we find at least one character that we can map.\n        while (rawValueArr.length > 0) {\n          // Let's retrieve the first user character in the queue of characters we have left\n          const { char: rawValueChar, isNew } = rawValueArr.shift();\n\n          // If the character we got from the user input is a placeholder character (which happens\n          // regularly because user input could be something like (540) 90_-____, which includes\n          // a bunch of `_` which are placeholder characters) and we are not in *no guide* mode,\n          // then we map this placeholder character to the current spot in the placeholder\n          if (rawValueChar === placeholderChar && suppressGuide !== true) {\n            conformedValue += placeholderChar;\n\n            // And we go to find the next placeholder character that needs filling\n            continue placeholderLoop;\n\n            // Else if, the character we got from the user input is not a placeholder, let's see\n            // if the current position in the mask can accept it.\n          } else if (mask[i].test(rawValueChar)) {\n            // we map the character differently based on whether we are keeping character positions or not.\n            // If any of the conditions below are met, we simply map the raw value character to the\n            // placeholder position.\n            if (\n              keepCharPositions !== true ||\n              isNew === false ||\n              previousConformedValue === emptyString ||\n              guide === false ||\n              !isAddition\n            ) {\n              conformedValue += rawValueChar;\n            } else {\n              // We enter this block of code if we are trying to keep character positions and none of the conditions\n              // above is met. In this case, we need to see if there's an available spot for the raw value character\n              // to be mapped to. If we couldn't find a spot, we will discard the character.\n              //\n              // For example, for mask `1111`, previous conformed value `_2__`, raw value `942_2__`. We can map the\n              // `9`, to the first available placeholder position, but then, there are no more spots available for the\n              // `4` and `2`. So, we discard them and end up with a conformed value of `92__`.\n              const rawValueArrLength = rawValueArr.length;\n              let indexOfNextAvailablePlaceholderChar = null;\n\n              // Let's loop through the remaining raw value characters. We are looking for either a suitable spot, ie,\n              // a placeholder character or a non-suitable spot, ie, a non-placeholder character that is not new.\n              // If we see a suitable spot first, we store its position and exit the loop. If we see a non-suitable\n              // spot first, we exit the loop and our `indexOfNextAvailablePlaceholderChar` will stay as `null`.\n              for (let j = 0; j < rawValueArrLength; j++) {\n                const charData = rawValueArr[j];\n\n                if (\n                  charData.char !== placeholderChar &&\n                  charData.isNew === false\n                ) {\n                  break;\n                }\n\n                if (charData.char === placeholderChar) {\n                  indexOfNextAvailablePlaceholderChar = j;\n                  break;\n                }\n              }\n\n              // If `indexOfNextAvailablePlaceholderChar` is not `null`, that means the character is not blocked.\n              // We can map it. And to keep the character positions, we remove the placeholder character\n              // from the remaining characters\n              if (indexOfNextAvailablePlaceholderChar !== null) {\n                conformedValue += rawValueChar;\n                rawValueArr.splice(indexOfNextAvailablePlaceholderChar, 1);\n\n                // If `indexOfNextAvailablePlaceholderChar` is `null`, that means the character is blocked. We have to\n                // discard it.\n              } else {\n                i--;\n              }\n            }\n\n            // Since we've mapped this placeholder position. We move on to the next one.\n            continue placeholderLoop;\n          } else {\n            someCharsRejected = true;\n          }\n        }\n      }\n\n      // We reach this point when we've mapped all the user input characters to placeholder\n      // positions in the mask. In *guide* mode, we append the left over characters in the\n      // placeholder to the `conformedString`, but in *no guide* mode, we don't wanna do that.\n      //\n      // That is, for mask `(111)` and user input `2`, we want to return `(2`, not `(2__)`.\n      if (suppressGuide === false) {\n        conformedValue += placeholder.substr(i, placeholderLength);\n      }\n\n      // And we break\n      break;\n\n      // Else, the charInPlaceholder is not a placeholderChar. That is, we cannot fill it\n      // with user input. So we just map it to the final output\n    } else {\n      conformedValue += charInPlaceholder;\n    }\n  }\n\n  // The following logic is needed to deal with the case of deletion in *no guide* mode.\n  //\n  // Consider the silly mask `(111) /// 1`. What if user tries to delete the last placeholder\n  // position? Something like `(589) /// `. We want to conform that to `(589`. Not `(589) /// `.\n  // That's why the logic below finds the last filled placeholder character, and removes everything\n  // from that point on.\n  if (suppressGuide && isAddition === false) {\n    let indexOfLastFilledPlaceholderChar = null;\n\n    // Find the last filled placeholder position and substring from there\n    for (let i = 0; i < conformedValue.length; i++) {\n      if (placeholder[i] === placeholderChar) {\n        indexOfLastFilledPlaceholderChar = i;\n      }\n    }\n\n    if (indexOfLastFilledPlaceholderChar !== null) {\n      // We substring from the beginning until the position after the last filled placeholder char.\n      conformedValue = conformedValue.substr(\n        0,\n        indexOfLastFilledPlaceholderChar + 1,\n      );\n    } else {\n      // If we couldn't find `indexOfLastFilledPlaceholderChar` that means the user deleted\n      // the first character in the mask. So we return an empty string.\n      conformedValue = emptyString;\n    }\n  }\n\n  return { conformedValue, meta: { someCharsRejected } };\n}\n","import { adjustCaretPosition } from './adjust-caret-position.function';\nimport {\n  conformToMask,\n  defaultPlaceholderChar,\n  processCaretTraps,\n} from './conform-to-mask.function';\n\nconst emptyArray = [];\nconst emptyString = '';\n\nconst isAndroid =\n  typeof navigator !== 'undefined' && /Android/i.test(navigator.userAgent);\nconst defer: any =\n  typeof requestAnimationFrame !== 'undefined'\n    ? requestAnimationFrame\n    : setTimeout;\n\nfunction isString(value: any): boolean {\n  return typeof value === 'string' || value instanceof String;\n}\n\nfunction isNumber(value: any): boolean {\n  return (\n    typeof value === 'number' &&\n    (value as any).length === undefined &&\n    !isNaN(value)\n  );\n}\n\nexport function convertMaskToPlaceholder(\n  mask: any = emptyArray,\n  placeholderChar: string = defaultPlaceholderChar,\n): any {\n  if (!Array.isArray(mask)) {\n    throw new Error(\n      'Text-mask:convertMaskToPlaceholder; The mask property must be an array.',\n    );\n  }\n\n  if (mask.indexOf(placeholderChar) !== -1) {\n    throw new Error(\n      'Placeholder character must not be used as part of the mask. Please specify a character ' +\n        'that is not present in your mask as your placeholder character.\\n\\n' +\n        `The placeholder character that was received is: ${JSON.stringify(\n          placeholderChar,\n        )}\\n\\n` +\n        `The mask that was received is: ${JSON.stringify(mask)}`,\n    );\n  }\n\n  return mask\n    .map((char) => {\n      return char instanceof RegExp ? placeholderChar : char;\n    })\n    .join('');\n}\n\nexport function createTextMaskInputElement(\n  config: any,\n): { state: any; update: any } {\n  // Anything that we will need to keep between `update` calls, we will store in this `state` object.\n  const state = {\n    previousConformedValue: undefined,\n    previousPlaceholder: undefined,\n  };\n\n  return {\n    state,\n\n    // `update` is called by framework components whenever they want to update the `value` of the input element.\n    // The caller can send a `rawValue` to be conformed and set on the input element. However, the default use-case\n    // is for this to be read from the `inputElement` directly.\n    update(\n      rawValue: any,\n      {\n        inputElement,\n        mask: providedMask,\n        guide,\n        pipe,\n        placeholderChar = defaultPlaceholderChar,\n        keepCharPositions = false,\n        showMask = false,\n      }: any = config,\n    ): void {\n      // if `rawValue` is `undefined`, read from the `inputElement`\n      if (typeof rawValue === 'undefined') {\n        rawValue = inputElement.value;\n      }\n\n      // If `rawValue` equals `state.previousConformedValue`, we don't need to change anything. So, we return.\n      // This check is here to handle controlled framework components that repeat the `update` call on every render.\n      if (rawValue === state.previousConformedValue) {\n        return;\n      }\n\n      // Text Mask accepts masks that are a combination of a `mask` and a `pipe` that work together. If such a `mask` is\n      // passed, we de-structure it below, so the rest of the code can work normally as if a separate `mask` and a `pipe`\n      // were passed.\n      if (\n        typeof providedMask === 'object' &&\n        providedMask.pipe !== undefined &&\n        providedMask.mask !== undefined\n      ) {\n        pipe = providedMask.pipe;\n        providedMask = providedMask.mask;\n      }\n\n      // The `placeholder` is an essential piece of how Text Mask works. For a mask like `(111)`, the placeholder would\n      // be `(___)` if the `placeholderChar` is set to `_`.\n      let placeholder;\n\n      // We don't know what the mask would be yet. If it is an array, we take it as is, but if it's a function, we will\n      // have to call that function to get the mask array.\n      let mask;\n\n      // If the provided mask is an array, we can call `convertMaskToPlaceholder` here once and we'll always have the\n      // correct `placeholder`.\n      if (providedMask instanceof Array) {\n        placeholder = convertMaskToPlaceholder(providedMask, placeholderChar);\n      }\n\n      // In framework components that support reactivity, it's possible to turn off masking by passing\n      // `false` for `mask` after initialization. See https://github.com/text-mask/text-mask/pull/359\n      if (providedMask === false) {\n        return;\n      }\n\n      // We check the provided `rawValue` before moving further.\n      // If it's something we can't work with `getSafeRawValue` will throw.\n      const safeRawValue = getSafeRawValue(rawValue);\n\n      // `selectionEnd` indicates to us where the caret position is after the user has typed into the input\n      const { selectionEnd: currentCaretPosition } = inputElement;\n\n      // We need to know what the `previousConformedValue` and `previousPlaceholder` is from the previous `update` call\n      const { previousConformedValue, previousPlaceholder } = state;\n\n      let caretTrapIndexes;\n\n      // If the `providedMask` is a function. We need to call it at every `update` to get the `mask` array.\n      // Then we also need to get the `placeholder`\n      if (typeof providedMask === 'function') {\n        mask = providedMask(safeRawValue, {\n          currentCaretPosition,\n          previousConformedValue,\n          placeholderChar,\n        });\n\n        // disable masking if `mask` is `false`\n        if (mask === false) {\n          return;\n        }\n\n        // mask functions can setup caret traps to have some control over how the caret moves. We need to process\n        // the mask for any caret traps. `processCaretTraps` will remove the caret traps from the mask and return\n        // the indexes of the caret traps.\n        const { maskWithoutCaretTraps, indexes } = processCaretTraps(mask);\n\n        mask = maskWithoutCaretTraps; // The processed mask is what we're interested in\n        caretTrapIndexes = indexes; // And we need to store these indexes because they're needed by `adjustCaretPosition`\n\n        placeholder = convertMaskToPlaceholder(mask, placeholderChar);\n\n        // If the `providedMask` is not a function, we just use it as-is.\n      } else {\n        mask = providedMask;\n      }\n\n      // The following object will be passed to `conformToMask` to determine how the `rawValue` will be conformed\n      const conformToMaskConfig = {\n        previousConformedValue,\n        guide,\n        placeholderChar,\n        pipe,\n        placeholder,\n        currentCaretPosition,\n        keepCharPositions,\n      };\n\n      // `conformToMask` returns `conformedValue` as part of an object for future API flexibility\n      const { conformedValue } = conformToMask(\n        safeRawValue,\n        mask,\n        conformToMaskConfig,\n      );\n\n      // The following few lines are to support the `pipe` feature.\n      const piped = typeof pipe === 'function';\n\n      let pipeResults = {};\n\n      // If `pipe` is a function, we call it.\n      if (piped) {\n        // `pipe` receives the `conformedValue` and the configurations with which `conformToMask` was called.\n        pipeResults = pipe(conformedValue, {\n          rawValue: safeRawValue,\n          ...conformToMaskConfig,\n        });\n\n        // `pipeResults` should be an object. But as a convenience, we allow the pipe author to just return `false` to\n        // indicate rejection. Or return just a string when there are no piped characters.\n        // If the `pipe` returns `false` or a string, the block below turns it into an object that the rest\n        // of the code can work with.\n        if (pipeResults === false) {\n          // If the `pipe` rejects `conformedValue`, we use the `previousConformedValue`, and set `rejected` to `true`.\n          pipeResults = { value: previousConformedValue, rejected: true };\n        } else if (isString(pipeResults)) {\n          pipeResults = { value: pipeResults };\n        }\n      }\n\n      // Before we proceed, we need to know which conformed value to use, the one returned by the pipe or the one\n      // returned by `conformToMask`.\n      const finalConformedValue = piped\n        ? (pipeResults as any).value\n        : conformedValue;\n\n      // After determining the conformed value, we will need to know where to set\n      // the caret position. `adjustCaretPosition` will tell us.\n      const adjustedCaretPosition = adjustCaretPosition({\n        previousConformedValue,\n        previousPlaceholder,\n        conformedValue: finalConformedValue,\n        placeholder,\n        rawValue: safeRawValue,\n        currentCaretPosition,\n        placeholderChar,\n        indexesOfPipedChars: (pipeResults as any).indexesOfPipedChars,\n        caretTrapIndexes,\n      });\n\n      // Text Mask sets the input value to an empty string when the condition below is set. It provides a better UX.\n      const inputValueShouldBeEmpty =\n        finalConformedValue === placeholder && adjustedCaretPosition === 0;\n      const emptyValue = showMask ? placeholder : emptyString;\n      const inputElementValue = inputValueShouldBeEmpty\n        ? emptyValue\n        : finalConformedValue;\n\n      state.previousConformedValue = inputElementValue; // store value for access for next time\n      state.previousPlaceholder = placeholder;\n\n      // In some cases, this `update` method will be repeatedly called with a raw value that has already been conformed\n      // and set to `inputElement.value`. The below check guards against needlessly readjusting the input state.\n      // See https://github.com/text-mask/text-mask/issues/231\n      if (inputElement.value === inputElementValue) {\n        return;\n      }\n\n      inputElement.value = inputElementValue; // set the input value\n      safeSetSelection(inputElement, adjustedCaretPosition); // adjust caret position\n    },\n  };\n}\n\nfunction safeSetSelection(element: any, selectionPosition: any): any {\n  if (document.activeElement === element) {\n    if (isAndroid) {\n      defer(\n        () =>\n          element.setSelectionRange(\n            selectionPosition,\n            selectionPosition,\n            'none',\n          ),\n        0,\n      );\n    } else {\n      element.setSelectionRange(selectionPosition, selectionPosition, 'none');\n    }\n  }\n}\n\nfunction getSafeRawValue(inputValue: any): any {\n  if (isString(inputValue)) {\n    return inputValue;\n  } else if (isNumber(inputValue)) {\n    return String(inputValue);\n  } else if (inputValue === undefined || inputValue === null) {\n    return emptyString;\n  } else {\n    throw new Error(\n      \"The 'value' provided to Text Mask needs to be a string or a number. The value \" +\n        `received was:\\n\\n ${JSON.stringify(inputValue)}`,\n    );\n  }\n}\n","import {\n  Directive,\n  ElementRef,\n  forwardRef,\n  Inject,\n  Input,\n  NgModule,\n  OnChanges,\n  Optional,\n  Provider,\n  Renderer2,\n  SimpleChanges,\n} from '@angular/core';\nimport {\n  COMPOSITION_BUFFER_MODE,\n  ControlValueAccessor,\n  NG_VALUE_ACCESSOR,\n} from '@angular/forms';\nimport { getDOM as getDOM } from '@angular/platform-browser';\nimport { createTextMaskInputElement } from './mask/create-text-mask-input-element.function';\n\nexport class TextMaskConfig {\n  mask:\n    | Array<string | RegExp>\n    | ((raw: string) => Array<string | RegExp>)\n    | false;\n  guide?: boolean;\n  placeholderChar?: string;\n  pipe?: (\n    conformedValue: string,\n    config: TextMaskConfig,\n  ) => false | string | object;\n  keepCharPositions?: boolean;\n  showMask?: boolean;\n}\n\nexport const MASKEDINPUT_VALUE_ACCESSOR: Provider = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => MaskedInputDirective),\n  multi: true,\n};\n\n/**\n * We must check whether the agent is Android because composition events\n * behave differently between iOS and Android.\n */\nfunction _isAndroid(): boolean {\n  const userAgent = getDOM() ? getDOM().getUserAgent() : '';\n  return /android (\\d+)/.test(userAgent.toLowerCase());\n}\n\n@Directive({\n  host: {\n    '(input)': '_handleInput($event.target.value)',\n    '(blur)': 'onTouched()',\n    '(compositionstart)': '_compositionStart()',\n    '(compositionend)': '_compositionEnd($event.target.value)',\n  },\n  selector: '[textMask]',\n  exportAs: 'textMask',\n  providers: [MASKEDINPUT_VALUE_ACCESSOR],\n})\nexport class MaskedInputDirective implements ControlValueAccessor, OnChanges {\n  @Input('textMask') textMaskConfig: TextMaskConfig = {\n    mask: [],\n    guide: true,\n    placeholderChar: '_',\n    pipe: undefined,\n    keepCharPositions: false,\n  };\n\n  private textMaskInputElement: any;\n  private inputElement: HTMLInputElement;\n\n  /** Whether the user is creating a composition string (IME events). */\n  private _composing: boolean = false;\n\n  constructor(\n    private _renderer: Renderer2,\n    private _elementRef: ElementRef,\n    @Optional()\n    @Inject(COMPOSITION_BUFFER_MODE)\n    private _compositionMode: boolean,\n  ) {\n    if (this._compositionMode == null) {\n      this._compositionMode = !_isAndroid();\n    }\n  }\n\n  onChange = (_: any) => {\n    // noop\n  };\n  onTouched = () => {\n    // noop\n  };\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this._setupMask(true);\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  }\n\n  writeValue(value: any): void {\n    this._setupMask();\n\n    // set the initial value for cases where the mask is disabled\n    const normalizedValue = value == null ? '' : value;\n    this._renderer.setProperty(this.inputElement, 'value', normalizedValue);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value);\n    }\n  }\n\n  registerOnChange(fn: (_: any) => void): void {\n    this.onChange = fn;\n  }\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this._renderer.setProperty(\n      this._elementRef.nativeElement,\n      'disabled',\n      isDisabled,\n    );\n  }\n\n  _handleInput(value: any): void {\n    if (!this._compositionMode || (this._compositionMode && !this._composing)) {\n      this._setupMask();\n\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value);\n\n        // get the updated value\n        value = this.inputElement.value;\n        this.onChange(value);\n      }\n    }\n  }\n\n  _setupMask(create: boolean = false): void {\n    if (!this.inputElement) {\n      if (this._elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this._elementRef.nativeElement;\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this._elementRef.nativeElement.getElementsByTagName(\n          'INPUT',\n        )[0];\n      }\n    }\n\n    if (this.inputElement && create) {\n      this.textMaskInputElement = createTextMaskInputElement(\n        Object.assign({ inputElement: this.inputElement }, this.textMaskConfig),\n      );\n    }\n  }\n\n  _compositionStart(): void {\n    this._composing = true;\n  }\n\n  _compositionEnd(value: any): void {\n    this._composing = false;\n    if (this._compositionMode) {\n      this._handleInput(value);\n    }\n  }\n}\n\n@NgModule({\n  declarations: [MaskedInputDirective],\n  exports: [MaskedInputDirective],\n})\nexport class TextMaskModule {}\n","export const clean = (number: string) => {\n  return number.toString().replace(/[^\\d\\^\\+]/gm, '');\n};\n\nexport const mask = (maxLength: number = 13) => (rawValue: string) => {\n  // if (clean(rawValue).length <= 12 || maxLength === 12) {\n  // \treturn ['+', /[1-9]/, ' ', '(', /[1-9]/, /\\d/, /\\d/, ')', ' ', /\\d/, /\\d/, /\\d/, '-', /\\d/, /\\d/, '-', /\\d/, /\\d/];\n  // }\n\n  return [\n    '(',\n    /[1-9]/,\n    /\\d/,\n    /\\d/,\n    ')',\n    ' ',\n    /\\d/,\n    /\\d/,\n    /\\d/,\n    '-',\n    /\\d/,\n    /\\d/,\n    /\\d/,\n    /\\d/,\n  ];\n};\n","import { isPlatformBrowser } from '@angular/common';\nimport {\n  Directive,\n  ElementRef,\n  forwardRef,\n  HostListener,\n  Inject,\n  Input,\n  OnChanges,\n  OnInit,\n  Optional,\n  PLATFORM_ID,\n  Renderer2,\n  SimpleChanges,\n} from '@angular/core';\nimport {\n  COMPOSITION_BUFFER_MODE,\n  ControlValueAccessor,\n  NG_VALUE_ACCESSOR,\n} from '@angular/forms';\nimport { createTextMaskInputElement } from '../mask/create-text-mask-input-element.function';\nimport { clean, mask } from './utils';\n\nexport class TextMaskConfig {\n  public mask:\n    | Array<string | RegExp>\n    | ((raw: string) => Array<string | RegExp>)\n    | false;\n  public guide?: boolean;\n  public placeholderChar?: string;\n  public pipe?: (\n    conformedValue: string,\n    config: TextMaskConfig,\n  ) => false | string | object;\n  public keepCharPositions?: boolean;\n  public showMask?: boolean;\n}\n\n// @dynamic\n@Directive({\n  exportAs: 'cntMaskPhone',\n  providers: [\n    {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => PhoneMaskDirective),\n    },\n  ],\n  selector: '[cntMaskPhone]',\n})\nexport class PhoneMaskDirective\n  implements ControlValueAccessor, OnChanges, OnInit {\n  @Input() public clean: boolean = true;\n  @Input() public maxNumberLength: number = 13;\n\n  public textMaskConfig: TextMaskConfig;\n\n  private textMaskInputElement: any;\n  private inputElement: HTMLInputElement;\n\n  /** Whether the user is creating a composition string (IME events). */\n  private composing: boolean = false;\n\n  constructor(\n    private renderer: Renderer2,\n    private elementRef: ElementRef,\n    @Inject(PLATFORM_ID) private platformId: object,\n    @Optional()\n    @Inject(COMPOSITION_BUFFER_MODE)\n    private compositionMode: boolean,\n  ) {\n    if (this.compositionMode == null) {\n      this.compositionMode = !this.isAndroid();\n    }\n  }\n\n  public onChange = (_: any) => {\n    // implement\n  };\n\n  public onTouched = () => {\n    // implement\n  };\n\n  ngOnInit(): void {\n    this.setupMask(true);\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  }\n\n  ngOnChanges(changes: SimpleChanges): void {\n    this.setupMask(true);\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(this.inputElement.value);\n    }\n  }\n\n  @HostListener('blur')\n  onBlur(): void {\n    this.onTouched();\n  }\n\n  writeValue(value: any): void {\n    this.setupMask();\n\n    // set the initial value for cases where the mask is disabled\n    const normalizedValue = value == null ? '' : value;\n    this.renderer.setProperty(this.inputElement, 'value', normalizedValue);\n\n    if (this.textMaskInputElement !== undefined) {\n      this.textMaskInputElement.update(value);\n    }\n  }\n\n  registerOnChange(fn: (_: any) => void): void {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: () => void): void {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean): void {\n    this.renderer.setProperty(\n      this.elementRef.nativeElement,\n      'disabled',\n      isDisabled,\n    );\n  }\n\n  @HostListener('input', ['$event.target.value'])\n  handleInput(value: string): void {\n    if (!this.compositionMode || (this.compositionMode && !this.composing)) {\n      this.setupMask();\n\n      if (this.textMaskInputElement !== undefined) {\n        this.textMaskInputElement.update(value);\n\n        // get the updated value\n        value = this.inputElement.value;\n\n        if (this.clean) {\n          this.onChange(clean(value));\n        } else {\n          this.onChange(value);\n        }\n      }\n    }\n  }\n\n  setupMask(create: boolean = false): void {\n    this.textMaskConfig = {\n      mask: mask(this.maxNumberLength),\n      guide: false,\n      placeholderChar: '_',\n      pipe: undefined,\n      keepCharPositions: false,\n    };\n    if (!this.inputElement) {\n      if (this.elementRef.nativeElement.tagName.toUpperCase() === 'INPUT') {\n        // `textMask` directive is used directly on an input element\n        this.inputElement = this.elementRef.nativeElement;\n      } else {\n        // `textMask` directive is used on an abstracted input element, `md-input-container`, etc\n        this.inputElement = this.elementRef.nativeElement.getElementsByTagName(\n          'INPUT',\n        )[0];\n      }\n    }\n\n    if (this.inputElement && create) {\n      this.textMaskInputElement = createTextMaskInputElement(\n        Object.assign({ inputElement: this.inputElement }, this.textMaskConfig),\n      );\n    }\n  }\n\n  @HostListener('compositionstart')\n  compositionStart(): void {\n    this.composing = true;\n  }\n\n  @HostListener('compositionend', ['$event.target.value'])\n  compositionEnd(value: any): void {\n    this.composing = false;\n    // tslint:disable-next-line: no-unused-expression\n    this.compositionMode && this.handleInput(value);\n  }\n\n  /**\n   * We must check whether the agent is Android because composition events\n   * behave differently between iOS and Android.\n   */\n  private isAndroid(): boolean {\n    if (\n      isPlatformBrowser(this.platformId) &&\n      window &&\n      (window as any).navigator\n    ) {\n      const userAgent = window.navigator.userAgent;\n      return /android (\\d+)/.test(userAgent.toLowerCase());\n    }\n\n    return false;\n  }\n}\n","import { Pipe, PipeTransform } from '@angular/core';\nimport { conformToMask } from '../mask/conform-to-mask.function';\nimport { mask } from './utils';\n\n@Pipe({\n  name: 'cntMaskPhone',\n})\nexport class PhoneMaskPipe implements PipeTransform {\n  transform(value: string): string {\n    if (!value) {\n      return '';\n    }\n\n    return conformToMask(value, mask(), { guide: false }).conformedValue;\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { TextMaskModule } from './angular-2-text-mask.module';\nimport { CardExpirationPipe } from './cc/card-expiration.pipe';\nimport { CCCvcFormatDirective } from './cc/directives/cc-cvc-format.directive';\nimport { CCExpiryFormatDirective } from './cc/directives/cc-expiry-format.directive';\nimport { CCNumberFormatDirective } from './cc/directives/cc-number-format.directive';\nimport { PhoneMaskDirective } from './phone/phone-mask.directive';\nimport { PhoneMaskPipe } from './phone/phone-mask.pipe';\n\n@NgModule({\n  imports: [TextMaskModule],\n  declarations: [\n    CCNumberFormatDirective,\n    CCExpiryFormatDirective,\n    CCCvcFormatDirective,\n    CardExpirationPipe,\n    PhoneMaskDirective,\n    PhoneMaskPipe,\n  ],\n  exports: [\n    CCNumberFormatDirective,\n    CCExpiryFormatDirective,\n    CCCvcFormatDirective,\n    CardExpirationPipe,\n    PhoneMaskDirective,\n    PhoneMaskPipe,\n  ],\n  providers: [CardExpirationPipe, PhoneMaskPipe],\n})\nexport class CntMasksModule {}\n","import { Directive, forwardRef } from '@angular/core';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\n\n// @dynamic\n@Directive({\n  exportAs: 'cntMaskPhone',\n  providers: [\n    {\n      multi: true,\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => PhoneMaskDirectiveMock),\n    },\n  ],\n  selector: '[cntMaskPhone]',\n})\nexport class PhoneMaskDirectiveMock {}\n","import { Pipe, PipeTransform } from '@angular/core';\n\n@Pipe({\n  name: 'cntMaskPhone',\n})\nexport class PhoneMaskPipeMock implements PipeTransform {\n  transform(value: string): string {\n    return value;\n  }\n}\n","/*\n * Public API Surface of cnt-masks\n */\n\nexport * from './lib/cc/card-expiration.pipe';\nexport * from './lib/cc/card-expiration.pipe.mock';\nexport * from './lib/cc/directives/cc-cvc-format.directive';\nexport * from './lib/cc/directives/cc-cvc-format.directive.mock';\nexport * from './lib/cc/directives/cc-expiry-format.directive';\nexport * from './lib/cc/directives/cc-expiry-format.directive.mock';\nexport * from './lib/cc/directives/cc-number-format.directive';\nexport * from './lib/cc/directives/cc-number-format.directive.mock';\nexport * from './lib/cc/validators/credit-card.validator';\nexport * from './lib/cnt-masks.module';\nexport * from './lib/phone/phone-mask.directive';\nexport * from './lib/phone/phone-mask.directive.mock';\nexport * from './lib/phone/phone-mask.pipe';\nexport * from './lib/phone/phone-mask.pipe.mock';\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n\nexport {MASKEDINPUT_VALUE_ACCESSOR as a,MaskedInputDirective as b,TextMaskModule as c} from './lib/angular-2-text-mask.module';"],"names":["emptyString","emptyArray","convertMaskToPlaceholder","getDOM","TextMaskConfig"],"mappings":"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"}